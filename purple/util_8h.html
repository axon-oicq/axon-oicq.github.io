<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: util.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">util.h File Reference<div class="ingroups"><a class="el" href="group__core.html">libpurple</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &quot;<a class="el" href="account_8h_source.html">account.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="signals_8h_source.html">signals.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="xmlnode_8h_source.html">xmlnode.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="notify_8h_source.html">notify.h</a>&quot;</code><br />
</div>
<p><a href="util_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__PurpleMenuAction.html">_PurpleMenuAction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__PurpleKeyValuePair.html">_PurpleKeyValuePair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a50b40180707a9a22d02ec51665c833b0"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__PurpleUtilFetchUrlData.html">_PurpleUtilFetchUrlData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a50b40180707a9a22d02ec51665c833b0">PurpleUtilFetchUrlData</a></td></tr>
<tr class="separator:a50b40180707a9a22d02ec51665c833b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a9aeda99658e0bbf306ff959195c7c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__PurpleMenuAction.html">_PurpleMenuAction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a64a9aeda99658e0bbf306ff959195c7c">PurpleMenuAction</a></td></tr>
<tr class="separator:a64a9aeda99658e0bbf306ff959195c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec84f879aeeb89d7f16a7a458a7e643"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__PurpleKeyValuePair.html">_PurpleKeyValuePair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#abec84f879aeeb89d7f16a7a458a7e643">PurpleKeyValuePair</a></td></tr>
<tr class="separator:abec84f879aeeb89d7f16a7a458a7e643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39e6ef1d5a0dc549f9f9b07f49fb876"><td class="memItemLeft" align="right" valign="top"><a id="ab39e6ef1d5a0dc549f9f9b07f49fb876" name="ab39e6ef1d5a0dc549f9f9b07f49fb876"></a>
typedef char *(*&#160;</td><td class="memItemRight" valign="bottom"><b>PurpleInfoFieldFormatCallback</b>) (const char *field, size_t len)</td></tr>
<tr class="separator:ab39e6ef1d5a0dc549f9f9b07f49fb876"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9b0ee88eda377ea99b2dcae650a35f10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__PurpleMenuAction.html">PurpleMenuAction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a9b0ee88eda377ea99b2dcae650a35f10">purple_menu_action_new</a> (const char *label, PurpleCallback callback, gpointer data, GList *children)</td></tr>
<tr class="separator:a9b0ee88eda377ea99b2dcae650a35f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa2e10648a5c61a3af6c8a1c3145301"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#acaa2e10648a5c61a3af6c8a1c3145301">purple_menu_action_free</a> (<a class="el" href="struct__PurpleMenuAction.html">PurpleMenuAction</a> *act)</td></tr>
<tr class="separator:acaa2e10648a5c61a3af6c8a1c3145301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399eaa06a3bc2524b00d6c7726359a0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a399eaa06a3bc2524b00d6c7726359a0e">purple_util_set_current_song</a> (const char *title, const char *artist, const char *album)</td></tr>
<tr class="separator:a399eaa06a3bc2524b00d6c7726359a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082c5d11d206d570158359569b958dc0"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a082c5d11d206d570158359569b958dc0">purple_util_format_song_info</a> (const char *title, const char *artist, const char *album, gpointer unused)</td></tr>
<tr class="separator:a082c5d11d206d570158359569b958dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility Subsystem &lt;br&gt;</div></td></tr>
<tr class="memitem:ad2a9658a66cbce9424b093f9a83d090c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ad2a9658a66cbce9424b093f9a83d090c">purple_util_init</a> (void)</td></tr>
<tr class="separator:ad2a9658a66cbce9424b093f9a83d090c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237ab221a242219066c8030405d4c99f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a237ab221a242219066c8030405d4c99f">purple_util_uninit</a> (void)</td></tr>
<tr class="separator:a237ab221a242219066c8030405d4c99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Base16 Functions &lt;br&gt;</div></td></tr>
<tr class="memitem:a6f20310817f777a86ea31909488a4c46"><td class="memItemLeft" align="right" valign="top">gchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a6f20310817f777a86ea31909488a4c46">purple_base16_encode</a> (const guchar *data, gsize len)</td></tr>
<tr class="separator:a6f20310817f777a86ea31909488a4c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ae059b528927a4cbc44e8ac55a5553"><td class="memItemLeft" align="right" valign="top">guchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a36ae059b528927a4cbc44e8ac55a5553">purple_base16_decode</a> (const char *str, gsize *ret_len)</td></tr>
<tr class="separator:a36ae059b528927a4cbc44e8ac55a5553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a5178661316a5c08c1d1cf0429000a"><td class="memItemLeft" align="right" valign="top">gchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ad4a5178661316a5c08c1d1cf0429000a">purple_base16_encode_chunked</a> (const guchar *data, gsize len)</td></tr>
<tr class="separator:ad4a5178661316a5c08c1d1cf0429000a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Base64 Functions &lt;br&gt;</div></td></tr>
<tr class="memitem:a361a5839be3efb7dae777d2615820eb9"><td class="memItemLeft" align="right" valign="top">gchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a361a5839be3efb7dae777d2615820eb9">purple_base64_encode</a> (const guchar *data, gsize len)</td></tr>
<tr class="separator:a361a5839be3efb7dae777d2615820eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf6273aa8bb2aa36b54c7c2c735fa27"><td class="memItemLeft" align="right" valign="top">guchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#abaf6273aa8bb2aa36b54c7c2c735fa27">purple_base64_decode</a> (const char *str, gsize *ret_len)</td></tr>
<tr class="separator:abaf6273aa8bb2aa36b54c7c2c735fa27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Quoted Printable Functions &lt;br&gt;</div></td></tr>
<tr class="memitem:a5a863435e070cf060e73e9700b9a39c3"><td class="memItemLeft" align="right" valign="top">guchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a5a863435e070cf060e73e9700b9a39c3">purple_quotedp_decode</a> (const char *str, gsize *ret_len)</td></tr>
<tr class="separator:a5a863435e070cf060e73e9700b9a39c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">MIME Functions &lt;br&gt;</div></td></tr>
<tr class="memitem:a85db5a9404bd45b00e3e1559b492ee1e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a85db5a9404bd45b00e3e1559b492ee1e">purple_mime_decode_field</a> (const char *str)</td></tr>
<tr class="separator:a85db5a9404bd45b00e3e1559b492ee1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Markup Functions &lt;br&gt;</div></td></tr>
<tr class="memitem:a6622f65c9e85020aa07d3b0a8880b3e2"><td class="memItemLeft" align="right" valign="top">gchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a6622f65c9e85020aa07d3b0a8880b3e2">purple_markup_escape_text</a> (const gchar *text, gssize length)</td></tr>
<tr class="separator:a6622f65c9e85020aa07d3b0a8880b3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ebba86ab47dfd18b9a826814380dcf"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a35ebba86ab47dfd18b9a826814380dcf">purple_markup_find_tag</a> (const char *needle, const char *haystack, const char **start, const char **end, GData **attributes)</td></tr>
<tr class="separator:a35ebba86ab47dfd18b9a826814380dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450abc67be783d57310f023e9c3c36dd"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a450abc67be783d57310f023e9c3c36dd">purple_markup_extract_info_field</a> (const char *str, int len, <a class="el" href="struct__PurpleNotifyUserInfo.html">PurpleNotifyUserInfo</a> *user_info, const char *start_token, int skip, const char *end_token, char check_value, const char *no_value_token, const char *display_name, gboolean is_link, const char *link_prefix, PurpleInfoFieldFormatCallback format_cb)</td></tr>
<tr class="separator:a450abc67be783d57310f023e9c3c36dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f6a9384057b05e94fa66a3f6d63eda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#af8f6a9384057b05e94fa66a3f6d63eda">purple_markup_html_to_xhtml</a> (const char *html, char **dest_xhtml, char **dest_plain)</td></tr>
<tr class="separator:af8f6a9384057b05e94fa66a3f6d63eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f02bb7e180bb04fb74c8f39564902ee"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a0f02bb7e180bb04fb74c8f39564902ee">purple_markup_strip_html</a> (const char *str)</td></tr>
<tr class="separator:a0f02bb7e180bb04fb74c8f39564902ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc65ecc1aa13c2a455066d0dc65e54e5"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#abc65ecc1aa13c2a455066d0dc65e54e5">purple_markup_linkify</a> (const char *str)</td></tr>
<tr class="separator:abc65ecc1aa13c2a455066d0dc65e54e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9826f3952f9cb29e1f8da65221402cc8"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a9826f3952f9cb29e1f8da65221402cc8">purple_unescape_text</a> (const char *text)</td></tr>
<tr class="separator:a9826f3952f9cb29e1f8da65221402cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af562f060e55fbd17d4ec4630a040b52a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#af562f060e55fbd17d4ec4630a040b52a">purple_unescape_html</a> (const char *html)</td></tr>
<tr class="separator:af562f060e55fbd17d4ec4630a040b52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d46ee213ef2c0f4fdd7baa434f7a17b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a7d46ee213ef2c0f4fdd7baa434f7a17b">purple_markup_slice</a> (const char *str, guint x, guint y)</td></tr>
<tr class="separator:a7d46ee213ef2c0f4fdd7baa434f7a17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d57aec38cab8f689fe95078b2f6232d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a1d57aec38cab8f689fe95078b2f6232d">purple_markup_get_tag_name</a> (const char *tag)</td></tr>
<tr class="separator:a1d57aec38cab8f689fe95078b2f6232d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10086c08db5585062550a33647597237"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a10086c08db5585062550a33647597237">purple_markup_unescape_entity</a> (const char *text, int *length)</td></tr>
<tr class="separator:a10086c08db5585062550a33647597237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db1cbc21e8b24ed2fe2b6a026daa0d1"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a8db1cbc21e8b24ed2fe2b6a026daa0d1">purple_markup_get_css_property</a> (const gchar *style, const gchar *opt)</td></tr>
<tr class="separator:a8db1cbc21e8b24ed2fe2b6a026daa0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7164e0420813156ed7d28f44c127c7"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#aae7164e0420813156ed7d28f44c127c7">purple_markup_is_rtl</a> (const char *html)</td></tr>
<tr class="separator:aae7164e0420813156ed7d28f44c127c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Path/Filename Functions &lt;br&gt;</div></td></tr>
<tr class="memitem:a5d971e649260624b05135855651e80f0"><td class="memItemLeft" align="right" valign="top">const gchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a5d971e649260624b05135855651e80f0">purple_home_dir</a> (void)</td></tr>
<tr class="separator:a5d971e649260624b05135855651e80f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a391f407842384f56db8d381d44802"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a15a391f407842384f56db8d381d44802">purple_user_dir</a> (void)</td></tr>
<tr class="separator:a15a391f407842384f56db8d381d44802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5614c24a8453a142034eb56839cccd75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a5614c24a8453a142034eb56839cccd75">purple_util_set_user_dir</a> (const char *dir)</td></tr>
<tr class="separator:a5614c24a8453a142034eb56839cccd75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce8f03360a4f84019b1db9b9d81ef73"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a8ce8f03360a4f84019b1db9b9d81ef73">purple_build_dir</a> (const char *path, int mode)</td></tr>
<tr class="separator:a8ce8f03360a4f84019b1db9b9d81ef73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6251bd7f8c1eeca6fa426e9fa5b75616"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a6251bd7f8c1eeca6fa426e9fa5b75616">purple_util_write_data_to_file</a> (const char *filename, const char *data, gssize size)</td></tr>
<tr class="separator:a6251bd7f8c1eeca6fa426e9fa5b75616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd881d7b74ff1a48fe20ea63f364171"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a6dd881d7b74ff1a48fe20ea63f364171">purple_util_write_data_to_file_absolute</a> (const char *filename_full, const char *data, gssize size)</td></tr>
<tr class="separator:a6dd881d7b74ff1a48fe20ea63f364171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f00eb470981fd56d503dc1fc583e5b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__xmlnode.html">xmlnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a8f00eb470981fd56d503dc1fc583e5b6">purple_util_read_xml_from_file</a> (const char *filename, const char *description)</td></tr>
<tr class="separator:a8f00eb470981fd56d503dc1fc583e5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5015be993336467f21123a4638c658fa"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a5015be993336467f21123a4638c658fa">purple_mkstemp</a> (char **path, gboolean binary)</td></tr>
<tr class="separator:a5015be993336467f21123a4638c658fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e08707ed4489e9262b4c0577ca12d9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#af4e08707ed4489e9262b4c0577ca12d9">purple_util_get_image_extension</a> (gconstpointer data, size_t len)</td></tr>
<tr class="separator:af4e08707ed4489e9262b4c0577ca12d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025281925fad3ac1bb3363a19cbc1645"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a025281925fad3ac1bb3363a19cbc1645">purple_util_get_image_checksum</a> (gconstpointer image_data, size_t image_len)</td></tr>
<tr class="separator:a025281925fad3ac1bb3363a19cbc1645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681fa31034357f3c368772159d147c89"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a681fa31034357f3c368772159d147c89">purple_util_get_image_filename</a> (gconstpointer image_data, size_t image_len)</td></tr>
<tr class="separator:a681fa31034357f3c368772159d147c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Environment Detection Functions &lt;br&gt;</div></td></tr>
<tr class="memitem:aa1a122edb33c83912b96f01d7f10dd35"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#aa1a122edb33c83912b96f01d7f10dd35">purple_program_is_valid</a> (const char *program)</td></tr>
<tr class="separator:aa1a122edb33c83912b96f01d7f10dd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7853bf4f38acfb446c24dd009c9a5e4d"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a7853bf4f38acfb446c24dd009c9a5e4d">purple_running_gnome</a> (void)</td></tr>
<tr class="separator:a7853bf4f38acfb446c24dd009c9a5e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653222fd4dcd584737348f001f22d0ed"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a653222fd4dcd584737348f001f22d0ed">purple_running_kde</a> (void)</td></tr>
<tr class="separator:a653222fd4dcd584737348f001f22d0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa699b3ba92c849b29ed0c43b9e2b6026"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#aa699b3ba92c849b29ed0c43b9e2b6026">purple_running_osx</a> (void)</td></tr>
<tr class="separator:aa699b3ba92c849b29ed0c43b9e2b6026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba1636722a22f61b168d32a55ddff00"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#acba1636722a22f61b168d32a55ddff00">purple_fd_get_ip</a> (int fd)</td></tr>
<tr class="separator:acba1636722a22f61b168d32a55ddff00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad6976c14e906f47cdd7799c4d73cf6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#afad6976c14e906f47cdd7799c4d73cf6">purple_socket_get_family</a> (int fd)</td></tr>
<tr class="separator:afad6976c14e906f47cdd7799c4d73cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d917bc74dd82bb19f0f129f1c6be69"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ad1d917bc74dd82bb19f0f129f1c6be69">purple_socket_speaks_ipv4</a> (int fd)</td></tr>
<tr class="separator:ad1d917bc74dd82bb19f0f129f1c6be69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">String Functions &lt;br&gt;</div></td></tr>
<tr class="memitem:a323ebbe4227c69bbbda9d6d51a551700"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a323ebbe4227c69bbbda9d6d51a551700">purple_strequal</a> (const gchar *left, const gchar *right)</td></tr>
<tr class="separator:a323ebbe4227c69bbbda9d6d51a551700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59eedcc9bcce5d3eb2d4222b7bfd7cf8"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a59eedcc9bcce5d3eb2d4222b7bfd7cf8">purple_normalize</a> (const <a class="el" href="account_8h.html#ab9db46cb0fe2619a85a173379c1ae053">PurpleAccount</a> *account, const char *str)</td></tr>
<tr class="separator:a59eedcc9bcce5d3eb2d4222b7bfd7cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f0d41c22171b4bc05974b6f649e0cc"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a34f0d41c22171b4bc05974b6f649e0cc">purple_normalize_nocase</a> (const <a class="el" href="account_8h.html#ab9db46cb0fe2619a85a173379c1ae053">PurpleAccount</a> *account, const char *str)</td></tr>
<tr class="separator:a34f0d41c22171b4bc05974b6f649e0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcb029e51b1ec4e178c2cd983f39f65"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#affcb029e51b1ec4e178c2cd983f39f65">purple_str_has_prefix</a> (const char *s, const char *p)</td></tr>
<tr class="separator:affcb029e51b1ec4e178c2cd983f39f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ac2e13331d7abee380f056b2887d1f"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#aa2ac2e13331d7abee380f056b2887d1f">purple_str_has_suffix</a> (const char *s, const char *x)</td></tr>
<tr class="separator:aa2ac2e13331d7abee380f056b2887d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc484fa0cdfa1a9b8ea14c7e84eb1882"><td class="memItemLeft" align="right" valign="top">gchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#abc484fa0cdfa1a9b8ea14c7e84eb1882">purple_strdup_withhtml</a> (const gchar *src)</td></tr>
<tr class="separator:abc484fa0cdfa1a9b8ea14c7e84eb1882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808e5e8dd49120d79060a70504ed1924"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a808e5e8dd49120d79060a70504ed1924">purple_str_add_cr</a> (const char *str)</td></tr>
<tr class="separator:a808e5e8dd49120d79060a70504ed1924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00d237784cfa8b583bde380f5cb041c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ab00d237784cfa8b583bde380f5cb041c">purple_str_strip_char</a> (char *str, char thechar)</td></tr>
<tr class="separator:ab00d237784cfa8b583bde380f5cb041c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe273c36968ff02e8394bbebab791341"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#afe273c36968ff02e8394bbebab791341">purple_util_chrreplace</a> (char *string, char delimiter, char replacement)</td></tr>
<tr class="separator:afe273c36968ff02e8394bbebab791341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f899a78bd889d73319155c6ba8b671"><td class="memItemLeft" align="right" valign="top">gchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#af5f899a78bd889d73319155c6ba8b671">purple_strreplace</a> (const char *string, const char *delimiter, const char *replacement)</td></tr>
<tr class="separator:af5f899a78bd889d73319155c6ba8b671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7779a8687ca4379e40f96479d2c38b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a3f7779a8687ca4379e40f96479d2c38b">purple_utf8_ncr_encode</a> (const char *in)</td></tr>
<tr class="separator:a3f7779a8687ca4379e40f96479d2c38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548f23866a5382b1b18e5d589b665364"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a548f23866a5382b1b18e5d589b665364">purple_utf8_ncr_decode</a> (const char *in)</td></tr>
<tr class="separator:a548f23866a5382b1b18e5d589b665364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0fc428a02154bb117e8419ebd2c828"><td class="memItemLeft" align="right" valign="top">gchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a0d0fc428a02154bb117e8419ebd2c828">purple_strcasereplace</a> (const char *string, const char *delimiter, const char *replacement)</td></tr>
<tr class="separator:a0d0fc428a02154bb117e8419ebd2c828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebaac4388e025c69de474f5db0a30b2"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a3ebaac4388e025c69de474f5db0a30b2">purple_strcasestr</a> (const char *haystack, const char *needle)</td></tr>
<tr class="separator:a3ebaac4388e025c69de474f5db0a30b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4bca165934439c14f0b6003164cf6bd"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ab4bca165934439c14f0b6003164cf6bd">purple_str_size_to_units</a> (size_t size)</td></tr>
<tr class="separator:ab4bca165934439c14f0b6003164cf6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49247a6802f7787754d47ede44ecf474"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a49247a6802f7787754d47ede44ecf474">purple_str_seconds_to_string</a> (guint sec)</td></tr>
<tr class="separator:a49247a6802f7787754d47ede44ecf474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6cc259b46deb63585977e629b5ef456"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ad6cc259b46deb63585977e629b5ef456">purple_str_binary_to_ascii</a> (const unsigned char *binary, guint len)</td></tr>
<tr class="separator:ad6cc259b46deb63585977e629b5ef456"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Date/Time Functions &lt;br&gt;</h2></td></tr>
<tr class="memitem:abb3976d50829e995420f987c4c2a4343"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#abb3976d50829e995420f987c4c2a4343">PURPLE_NO_TZ_OFF</a>&#160;&#160;&#160;-500000</td></tr>
<tr class="separator:abb3976d50829e995420f987c4c2a4343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fcfa92cab47de233cfc4584c14f4e9e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a8fcfa92cab47de233cfc4584c14f4e9e">purple_utf8_strftime</a> (const char *format, const struct tm *tm)</td></tr>
<tr class="separator:a8fcfa92cab47de233cfc4584c14f4e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0eed4b5f40305734435dc5bda015f0f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ad0eed4b5f40305734435dc5bda015f0f">purple_get_tzoff_str</a> (const struct tm *tm, gboolean iso)</td></tr>
<tr class="separator:ad0eed4b5f40305734435dc5bda015f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f0a06e086286710ef7c6ad32446b3f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a30f0a06e086286710ef7c6ad32446b3f">purple_date_format_short</a> (const struct tm *tm)</td></tr>
<tr class="separator:a30f0a06e086286710ef7c6ad32446b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b5117a82094c6e63d41a7cb9b1f464"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a94b5117a82094c6e63d41a7cb9b1f464">purple_date_format_long</a> (const struct tm *tm)</td></tr>
<tr class="separator:a94b5117a82094c6e63d41a7cb9b1f464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6863db7f884d9673cb80af135e6cc40b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a6863db7f884d9673cb80af135e6cc40b">purple_date_format_full</a> (const struct tm *tm)</td></tr>
<tr class="separator:a6863db7f884d9673cb80af135e6cc40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5cc49e811038c29d40ae36a1f305f7"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a3e5cc49e811038c29d40ae36a1f305f7">purple_time_format</a> (const struct tm *tm)</td></tr>
<tr class="separator:a3e5cc49e811038c29d40ae36a1f305f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5921f52e7574a3fe170f277322202f1a"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a5921f52e7574a3fe170f277322202f1a">purple_time_build</a> (int year, int month, int day, int hour, int min, int sec)</td></tr>
<tr class="separator:a5921f52e7574a3fe170f277322202f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4881fba04ce7ff9ccf514c7b7214f59"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ab4881fba04ce7ff9ccf514c7b7214f59">purple_str_to_time</a> (const char *timestamp, gboolean utc, struct tm *tm, long *tz_off, const char **rest)</td></tr>
<tr class="separator:ab4881fba04ce7ff9ccf514c7b7214f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">URI/URL Functions &lt;br&gt;</h2></td></tr>
<tr class="memitem:a3a99b02ce53153ac1942b39107dfc26a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a3a99b02ce53153ac1942b39107dfc26a">purple_util_fetch_url</a>(url,  full,  user_agent,  http11,  cb,  data)</td></tr>
<tr class="separator:a3a99b02ce53153ac1942b39107dfc26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98268facf5e9575236f3b3c924ad6bc5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a98268facf5e9575236f3b3c924ad6bc5">purple_util_fetch_url_len</a>(url,  full,  user_agent,  http11,  max_len,  cb,  data)</td></tr>
<tr class="separator:a98268facf5e9575236f3b3c924ad6bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00476d778a70e0ab26523562cbd98dd1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a00476d778a70e0ab26523562cbd98dd1">purple_add_eight</a>(x)&#160;&#160;&#160;((x)+8)</td></tr>
<tr class="separator:a00476d778a70e0ab26523562cbd98dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad47dea3dfd7e801e022b472c5bf6bc"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a9ad47dea3dfd7e801e022b472c5bf6bc">PurpleUtilFetchUrlCallback</a>) (<a class="el" href="struct__PurpleUtilFetchUrlData.html">PurpleUtilFetchUrlData</a> *url_data, gpointer user_data, const gchar *url_text, gsize len, const gchar *error_message)</td></tr>
<tr class="separator:a9ad47dea3dfd7e801e022b472c5bf6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f8b899b452a74388348196b163b430"><td class="memItemLeft" align="right" valign="top"><a id="ab0f8b899b452a74388348196b163b430" name="ab0f8b899b452a74388348196b163b430"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>purple_got_protocol_handler_uri</b> (const char *uri)</td></tr>
<tr class="separator:ab0f8b899b452a74388348196b163b430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567d8d62b84abbbb74fc69a91041342e"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a567d8d62b84abbbb74fc69a91041342e">purple_url_parse</a> (const char *url, char **ret_host, int *ret_port, char **ret_path, char **ret_user, char **ret_passwd)</td></tr>
<tr class="separator:a567d8d62b84abbbb74fc69a91041342e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82426f03bee7c928390a1d299b752db4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__PurpleUtilFetchUrlData.html">PurpleUtilFetchUrlData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a82426f03bee7c928390a1d299b752db4">purple_util_fetch_url_request</a> (const gchar *url, gboolean full, const gchar *user_agent, gboolean http11, const gchar *request, gboolean include_headers, <a class="el" href="util_8h.html#a9ad47dea3dfd7e801e022b472c5bf6bc">PurpleUtilFetchUrlCallback</a> callback, gpointer data)</td></tr>
<tr class="separator:a82426f03bee7c928390a1d299b752db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d854ce14a2384e8fe4fb348b2beec5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__PurpleUtilFetchUrlData.html">PurpleUtilFetchUrlData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a75d854ce14a2384e8fe4fb348b2beec5">purple_util_fetch_url_request_len</a> (const gchar *url, gboolean full, const gchar *user_agent, gboolean http11, const gchar *request, gboolean include_headers, gssize max_len, <a class="el" href="util_8h.html#a9ad47dea3dfd7e801e022b472c5bf6bc">PurpleUtilFetchUrlCallback</a> callback, gpointer data)</td></tr>
<tr class="separator:a75d854ce14a2384e8fe4fb348b2beec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda0a23d9a4c351f2d435d9ca762f7a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__PurpleUtilFetchUrlData.html">PurpleUtilFetchUrlData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#adda0a23d9a4c351f2d435d9ca762f7a3">purple_util_fetch_url_request_len_with_account</a> (<a class="el" href="account_8h.html#ab9db46cb0fe2619a85a173379c1ae053">PurpleAccount</a> *account, const gchar *url, gboolean full, const gchar *user_agent, gboolean http11, const gchar *request, gboolean include_headers, gssize max_len, <a class="el" href="util_8h.html#a9ad47dea3dfd7e801e022b472c5bf6bc">PurpleUtilFetchUrlCallback</a> callback, gpointer data)</td></tr>
<tr class="separator:adda0a23d9a4c351f2d435d9ca762f7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165fb9bb6da5fc702751e2e9cb14a6e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__PurpleUtilFetchUrlData.html">PurpleUtilFetchUrlData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a165fb9bb6da5fc702751e2e9cb14a6e7">purple_util_fetch_url_request_data_len_with_account</a> (<a class="el" href="account_8h.html#ab9db46cb0fe2619a85a173379c1ae053">PurpleAccount</a> *account, const char *url, gboolean full, const char *user_agent, gboolean http11, const char *request, gsize request_len, gboolean include_headers, gssize max_len, <a class="el" href="util_8h.html#a9ad47dea3dfd7e801e022b472c5bf6bc">PurpleUtilFetchUrlCallback</a> callback, void *user_data)</td></tr>
<tr class="separator:a165fb9bb6da5fc702751e2e9cb14a6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8bb5e1415159f9f6feff94e7703cf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a2a8bb5e1415159f9f6feff94e7703cf2">purple_util_fetch_url_cancel</a> (<a class="el" href="struct__PurpleUtilFetchUrlData.html">PurpleUtilFetchUrlData</a> *url_data)</td></tr>
<tr class="separator:a2a8bb5e1415159f9f6feff94e7703cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9d6b81c1e831124a0d652e44610e8c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a6c9d6b81c1e831124a0d652e44610e8c">purple_url_decode</a> (const char *str)</td></tr>
<tr class="separator:a6c9d6b81c1e831124a0d652e44610e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae609f88e8b3214d18b7e5aa3fa00288f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ae609f88e8b3214d18b7e5aa3fa00288f">purple_url_encode</a> (const char *str)</td></tr>
<tr class="separator:ae609f88e8b3214d18b7e5aa3fa00288f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee3c58ada020f55850d22846bc7405e"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a7ee3c58ada020f55850d22846bc7405e">purple_email_is_valid</a> (const char *address)</td></tr>
<tr class="separator:a7ee3c58ada020f55850d22846bc7405e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ed8258810e98eb79ce9fb4727fabfa"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a11ed8258810e98eb79ce9fb4727fabfa">purple_ip_address_is_valid</a> (const char *ip)</td></tr>
<tr class="separator:a11ed8258810e98eb79ce9fb4727fabfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bb9f8fee426f3eb86481d684bea6a7"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a78bb9f8fee426f3eb86481d684bea6a7">purple_ipv4_address_is_valid</a> (const char *ip)</td></tr>
<tr class="separator:a78bb9f8fee426f3eb86481d684bea6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9375f51de090f20c8bf48f1ecb651e87"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a9375f51de090f20c8bf48f1ecb651e87">purple_ipv6_address_is_valid</a> (const char *ip)</td></tr>
<tr class="separator:a9375f51de090f20c8bf48f1ecb651e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88b47d173e5d05dd686fb7400685ef5"><td class="memItemLeft" align="right" valign="top">GList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ac88b47d173e5d05dd686fb7400685ef5">purple_uri_list_extract_uris</a> (const gchar *uri_list)</td></tr>
<tr class="separator:ac88b47d173e5d05dd686fb7400685ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986d3ca17265c46fbf117ff40f2e28d0"><td class="memItemLeft" align="right" valign="top">GList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a986d3ca17265c46fbf117ff40f2e28d0">purple_uri_list_extract_filenames</a> (const gchar *uri_list)</td></tr>
<tr class="separator:a986d3ca17265c46fbf117ff40f2e28d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2705811cc9c0f6503444dc1f43c3c90"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ad2705811cc9c0f6503444dc1f43c3c90">purple_uri_escape_for_open</a> (const char *unescaped)</td></tr>
<tr class="separator:ad2705811cc9c0f6503444dc1f43c3c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf23a59705602095dac13684628b102e"><td class="memItemLeft" align="right" valign="top">gchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#aaf23a59705602095dac13684628b102e">purple_utf8_try_convert</a> (const char *str)</td></tr>
<tr class="separator:aaf23a59705602095dac13684628b102e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd46ddcde4a365439cef7f0ad46d743"><td class="memItemLeft" align="right" valign="top">gchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a2dd46ddcde4a365439cef7f0ad46d743">purple_utf8_salvage</a> (const char *str)</td></tr>
<tr class="separator:a2dd46ddcde4a365439cef7f0ad46d743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b981dc639dbf50845cc70214fbc123"><td class="memItemLeft" align="right" valign="top">gchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a95b981dc639dbf50845cc70214fbc123">purple_utf8_strip_unprintables</a> (const gchar *str)</td></tr>
<tr class="separator:a95b981dc639dbf50845cc70214fbc123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56bb14339565e284dbdb159b41e3526f"><td class="memItemLeft" align="right" valign="top">const gchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a56bb14339565e284dbdb159b41e3526f">purple_gai_strerror</a> (gint errnum)</td></tr>
<tr class="separator:a56bb14339565e284dbdb159b41e3526f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3359c4de824a595855eec37c7503e2be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a3359c4de824a595855eec37c7503e2be">purple_utf8_strcasecmp</a> (const char *a, const char *b)</td></tr>
<tr class="separator:a3359c4de824a595855eec37c7503e2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af719fe21cd38649afac508a293ef0c9e"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#af719fe21cd38649afac508a293ef0c9e">purple_utf8_has_word</a> (const char *haystack, const char *needle)</td></tr>
<tr class="separator:af719fe21cd38649afac508a293ef0c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee3a1f4935e0bf32bb523fc6e30f22e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a7ee3a1f4935e0bf32bb523fc6e30f22e">purple_print_utf8_to_console</a> (FILE *filestream, char *message)</td></tr>
<tr class="separator:a7ee3a1f4935e0bf32bb523fc6e30f22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ce7b8c3dcabfde08353c85236dd07f"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a91ce7b8c3dcabfde08353c85236dd07f">purple_message_meify</a> (char *message, gssize len)</td></tr>
<tr class="separator:a91ce7b8c3dcabfde08353c85236dd07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cdffae48a389e72ea3e6688d34c3d4"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a07cdffae48a389e72ea3e6688d34c3d4">purple_text_strip_mnemonic</a> (const char *in)</td></tr>
<tr class="separator:a07cdffae48a389e72ea3e6688d34c3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245293bb6477ff6032c35ecf9484a527"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a245293bb6477ff6032c35ecf9484a527">purple_unescape_filename</a> (const char *str)</td></tr>
<tr class="separator:a245293bb6477ff6032c35ecf9484a527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3195bd144559f99b38df3b9f8e18aa2"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#aa3195bd144559f99b38df3b9f8e18aa2">purple_escape_filename</a> (const char *str)</td></tr>
<tr class="separator:aa3195bd144559f99b38df3b9f8e18aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d064f96ff78979f032ea3b68b52ecb"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#af4d064f96ff78979f032ea3b68b52ecb">_purple_oscar_convert</a> (const char *act, const char *protocol)</td></tr>
<tr class="separator:af4d064f96ff78979f032ea3b68b52ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5141ad67081cb08d507d3e8fbc857b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#aad5141ad67081cb08d507d3e8fbc857b">purple_restore_default_signal_handlers</a> (void)</td></tr>
<tr class="separator:aad5141ad67081cb08d507d3e8fbc857b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bac424814d508b63ac7542e038e9e50"><td class="memItemLeft" align="right" valign="top">const gchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a0bac424814d508b63ac7542e038e9e50">purple_get_host_name</a> (void)</td></tr>
<tr class="separator:a0bac424814d508b63ac7542e038e9e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a60bb236e1dd009c0eae05bb5cfa9e0"><td class="memItemLeft" align="right" valign="top">gchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a9a60bb236e1dd009c0eae05bb5cfa9e0">purple_uuid_random</a> (void)</td></tr>
<tr class="separator:a9a60bb236e1dd009c0eae05bb5cfa9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Utility Functions </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a00476d778a70e0ab26523562cbd98dd1" name="a00476d778a70e0ab26523562cbd98dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00476d778a70e0ab26523562cbd98dd1">&#9670;&nbsp;</a></span>purple_add_eight</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define purple_add_eight</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;((x)+8)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds 8 to something.</p>
<p >Blame SimGuy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The number to add 8 to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x + 8 </dd></dl>

</div>
</div>
<a id="abb3976d50829e995420f987c4c2a4343" name="abb3976d50829e995420f987c4c2a4343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3976d50829e995420f987c4c2a4343">&#9670;&nbsp;</a></span>PURPLE_NO_TZ_OFF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PURPLE_NO_TZ_OFF&#160;&#160;&#160;-500000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Used by purple_str_to_time to indicate no timezone offset was specified in the timestamp string. </p>

</div>
</div>
<a id="a3a99b02ce53153ac1942b39107dfc26a" name="a3a99b02ce53153ac1942b39107dfc26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a99b02ce53153ac1942b39107dfc26a">&#9670;&nbsp;</a></span>purple_util_fetch_url</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define purple_util_fetch_url</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">url, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">full, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">user_agent, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">http11, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cb, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code hl_function" href="util_8h.html#a82426f03bee7c928390a1d299b752db4">purple_util_fetch_url_request</a>(url, full, user_agent, http11, NULL, \</div>
<div class="line">        FALSE, cb, data);</div>
<div class="ttc" id="autil_8h_html_a82426f03bee7c928390a1d299b752db4"><div class="ttname"><a href="util_8h.html#a82426f03bee7c928390a1d299b752db4">purple_util_fetch_url_request</a></div><div class="ttdeci">PurpleUtilFetchUrlData * purple_util_fetch_url_request(const gchar *url, gboolean full, const gchar *user_agent, gboolean http11, const gchar *request, gboolean include_headers, PurpleUtilFetchUrlCallback callback, gpointer data)</div></div>
</div><!-- fragment --><p >Fetches the data from a URL, and passes it to a callback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>The URL. </td></tr>
    <tr><td class="paramname">full</td><td>TRUE if this is the full URL, or FALSE if it's a partial URL. </td></tr>
    <tr><td class="paramname">user_agent</td><td>The user agent field to use, or NULL. </td></tr>
    <tr><td class="paramname">http11</td><td>TRUE if HTTP/1.1 should be used to download the file. </td></tr>
    <tr><td class="paramname">cb</td><td>The callback function. </td></tr>
    <tr><td class="paramname">data</td><td>The user data to pass to the callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98268facf5e9575236f3b3c924ad6bc5" name="a98268facf5e9575236f3b3c924ad6bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98268facf5e9575236f3b3c924ad6bc5">&#9670;&nbsp;</a></span>purple_util_fetch_url_len</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define purple_util_fetch_url_len</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">url, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">full, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">user_agent, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">http11, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">max_len, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cb, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code hl_function" href="util_8h.html#a75d854ce14a2384e8fe4fb348b2beec5">purple_util_fetch_url_request_len</a>(url, full, user_agent, http11, NULL, \</div>
<div class="line">        FALSE, max_len, cb, data);</div>
<div class="ttc" id="autil_8h_html_a75d854ce14a2384e8fe4fb348b2beec5"><div class="ttname"><a href="util_8h.html#a75d854ce14a2384e8fe4fb348b2beec5">purple_util_fetch_url_request_len</a></div><div class="ttdeci">PurpleUtilFetchUrlData * purple_util_fetch_url_request_len(const gchar *url, gboolean full, const gchar *user_agent, gboolean http11, const gchar *request, gboolean include_headers, gssize max_len, PurpleUtilFetchUrlCallback callback, gpointer data)</div></div>
</div><!-- fragment --><p >Fetches the data from a URL, and passes it to a callback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>The URL. </td></tr>
    <tr><td class="paramname">full</td><td>TRUE if this is the full URL, or FALSE if it's a partial URL. </td></tr>
    <tr><td class="paramname">user_agent</td><td>The user agent field to use, or NULL. </td></tr>
    <tr><td class="paramname">http11</td><td>TRUE if HTTP/1.1 should be used to download the file. </td></tr>
    <tr><td class="paramname">max_len</td><td>The maximum number of bytes to retrieve (-1 for unlimited) </td></tr>
    <tr><td class="paramname">cb</td><td>The callback function. </td></tr>
    <tr><td class="paramname">data</td><td>The user data to pass to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000060">Deprecated:</a></b></dt><dd>In 3.0.0, we'll rename this to "purple_util_fetch_url" and get rid of the old one </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="abec84f879aeeb89d7f16a7a458a7e643" name="abec84f879aeeb89d7f16a7a458a7e643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec84f879aeeb89d7f16a7a458a7e643">&#9670;&nbsp;</a></span>PurpleKeyValuePair</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__PurpleKeyValuePair.html">_PurpleKeyValuePair</a> <a class="el" href="util_8h.html#abec84f879aeeb89d7f16a7a458a7e643">PurpleKeyValuePair</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p >A key-value pair.</p>
<p >This is used by, among other things, purple_gtk_combo* functions to pass in a list of key-value pairs so it can display a user-friendly value. </p>

</div>
</div>
<a id="a64a9aeda99658e0bbf306ff959195c7c" name="a64a9aeda99658e0bbf306ff959195c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a9aeda99658e0bbf306ff959195c7c">&#9670;&nbsp;</a></span>PurpleMenuAction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__PurpleMenuAction.html">_PurpleMenuAction</a> <a class="el" href="struct__PurpleMenuAction.html">PurpleMenuAction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a9ad47dea3dfd7e801e022b472c5bf6bc" name="a9ad47dea3dfd7e801e022b472c5bf6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad47dea3dfd7e801e022b472c5bf6bc">&#9670;&nbsp;</a></span>PurpleUtilFetchUrlCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* PurpleUtilFetchUrlCallback) (<a class="el" href="struct__PurpleUtilFetchUrlData.html">PurpleUtilFetchUrlData</a> *url_data, gpointer user_data, const gchar *url_text, gsize len, const gchar *error_message)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This is the signature used for functions that act as the callback to <a class="el" href="util_8h.html#a3a99b02ce53153ac1942b39107dfc26a">purple_util_fetch_url()</a> or <a class="el" href="util_8h.html#a82426f03bee7c928390a1d299b752db4">purple_util_fetch_url_request()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url_data</td><td>The same value that was returned when you called purple_fetch_url() or purple_fetch_url_request(). </td></tr>
    <tr><td class="paramname">user_data</td><td>The user data that your code passed into either <a class="el" href="util_8h.html#a3a99b02ce53153ac1942b39107dfc26a">purple_util_fetch_url()</a> or <a class="el" href="util_8h.html#a82426f03bee7c928390a1d299b752db4">purple_util_fetch_url_request()</a>. </td></tr>
    <tr><td class="paramname">url_text</td><td>This will be NULL on error. Otherwise this will contain the contents of the URL. </td></tr>
    <tr><td class="paramname">len</td><td>0 on error, otherwise this is the length of buf. </td></tr>
    <tr><td class="paramname">error_message</td><td>If something went wrong then this will contain a descriptive error message, and buf will be NULL and len will be 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50b40180707a9a22d02ec51665c833b0" name="a50b40180707a9a22d02ec51665c833b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b40180707a9a22d02ec51665c833b0">&#9670;&nbsp;</a></span>PurpleUtilFetchUrlData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__PurpleUtilFetchUrlData.html">_PurpleUtilFetchUrlData</a> <a class="el" href="struct__PurpleUtilFetchUrlData.html">PurpleUtilFetchUrlData</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >An opaque structure representing a URL request. Can be used to cancel the request. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af4d064f96ff78979f032ea3b68b52ecb" name="af4d064f96ff78979f032ea3b68b52ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d064f96ff78979f032ea3b68b52ecb">&#9670;&nbsp;</a></span>_purple_oscar_convert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * _purple_oscar_convert </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>act</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This is added temporarily to assist the split of oscar into aim and icq. This should not be used by plugins.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000065">Deprecated:</a></b></dt><dd>This function should not be used in new code and should be removed in 3.0.0. The aim/icq prpl split happened a long time ago, and we don't need to keep migrating old data. </dd></dl>

</div>
</div>
<a id="a36ae059b528927a4cbc44e8ac55a5553" name="a36ae059b528927a4cbc44e8ac55a5553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ae059b528927a4cbc44e8ac55a5553">&#9670;&nbsp;</a></span>purple_base16_decode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guchar * purple_base16_decode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize *&#160;</td>
          <td class="paramname"><em>ret_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Converts an ASCII string of base-16 encoded data to the binary equivalent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The base-16 string to convert to raw data. </td></tr>
    <tr><td class="paramname">ret_len</td><td>The length of the returned data. You can pass in NULL if you're sure that you know the length of the decoded data, or if you know you'll be able to use strlen to determine the length, etc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The raw data. Must be g_free'd when no longer needed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="util_8h.html#a6f20310817f777a86ea31909488a4c46">purple_base16_encode()</a> </dd></dl>

</div>
</div>
<a id="a6f20310817f777a86ea31909488a4c46" name="a6f20310817f777a86ea31909488a4c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f20310817f777a86ea31909488a4c46">&#9670;&nbsp;</a></span>purple_base16_encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gchar * purple_base16_encode </td>
          <td>(</td>
          <td class="paramtype">const guchar *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Converts a chunk of binary data to its base-16 equivalent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to convert. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The base-16 string in the ASCII encoding. Must be g_free'd when no longer needed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="util_8h.html#a36ae059b528927a4cbc44e8ac55a5553">purple_base16_decode()</a> </dd></dl>

</div>
</div>
<a id="ad4a5178661316a5c08c1d1cf0429000a" name="ad4a5178661316a5c08c1d1cf0429000a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a5178661316a5c08c1d1cf0429000a">&#9670;&nbsp;</a></span>purple_base16_encode_chunked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gchar * purple_base16_encode_chunked </td>
          <td>(</td>
          <td class="paramtype">const guchar *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Converts a chunk of binary data to a chunked base-16 representation (handy for key fingerprints)</p>
<p >Example output: 01:23:45:67:89:AB:CD:EF</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to convert. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The base-16 string in the ASCII chunked encoding. Must be g_free'd when no longer needed. </dd></dl>

</div>
</div>
<a id="abaf6273aa8bb2aa36b54c7c2c735fa27" name="abaf6273aa8bb2aa36b54c7c2c735fa27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf6273aa8bb2aa36b54c7c2c735fa27">&#9670;&nbsp;</a></span>purple_base64_decode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guchar * purple_base64_decode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize *&#160;</td>
          <td class="paramname"><em>ret_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Converts an ASCII string of base-64 encoded data to the binary equivalent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The base-64 string to convert to raw data. </td></tr>
    <tr><td class="paramname">ret_len</td><td>The length of the returned data. You can pass in NULL if you're sure that you know the length of the decoded data, or if you know you'll be able to use strlen to determine the length, etc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The raw data. Must be g_free'd when no longer needed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="util_8h.html#a361a5839be3efb7dae777d2615820eb9">purple_base64_encode()</a> </dd></dl>

</div>
</div>
<a id="a361a5839be3efb7dae777d2615820eb9" name="a361a5839be3efb7dae777d2615820eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a361a5839be3efb7dae777d2615820eb9">&#9670;&nbsp;</a></span>purple_base64_encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gchar * purple_base64_encode </td>
          <td>(</td>
          <td class="paramtype">const guchar *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Converts a chunk of binary data to its base-64 equivalent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to convert. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The base-64 string in the ASCII encoding. Must be g_free'd when no longer needed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="util_8h.html#abaf6273aa8bb2aa36b54c7c2c735fa27">purple_base64_decode()</a> </dd></dl>

</div>
</div>
<a id="a8ce8f03360a4f84019b1db9b9d81ef73" name="a8ce8f03360a4f84019b1db9b9d81ef73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce8f03360a4f84019b1db9b9d81ef73">&#9670;&nbsp;</a></span>purple_build_dir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int purple_build_dir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Builds a complete path from the root, making any directories along the path which do not already exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path you wish to create. Note that it must start from the root or this function will fail. </td></tr>
    <tr><td class="paramname">mode</td><td>Unix-style permissions for this directory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, nonzero on any error. </dd></dl>

</div>
</div>
<a id="a6863db7f884d9673cb80af135e6cc40b" name="a6863db7f884d9673cb80af135e6cc40b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6863db7f884d9673cb80af135e6cc40b">&#9670;&nbsp;</a></span>purple_date_format_full()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * purple_date_format_full </td>
          <td>(</td>
          <td class="paramtype">const struct tm *&#160;</td>
          <td class="paramname"><em>tm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Formats a time into the user's preferred full date and time format.</p>
<p >The returned string is stored in a static buffer, so the result should be g_strdup()'d if it's going to be kept.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tm</td><td>The time to format, or <code>NULL</code> to use the current local time</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The date and time, formatted as per the user's settings. </dd></dl>

</div>
</div>
<a id="a94b5117a82094c6e63d41a7cb9b1f464" name="a94b5117a82094c6e63d41a7cb9b1f464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b5117a82094c6e63d41a7cb9b1f464">&#9670;&nbsp;</a></span>purple_date_format_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * purple_date_format_long </td>
          <td>(</td>
          <td class="paramtype">const struct tm *&#160;</td>
          <td class="paramname"><em>tm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Formats a time into the user's preferred short date plus time format.</p>
<p >The returned string is stored in a static buffer, so the result should be g_strdup()'d if it's going to be kept.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tm</td><td>The time to format, or <code>NULL</code> to use the current local time</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The timestamp, formatted as per the user's settings. </dd></dl>

</div>
</div>
<a id="a30f0a06e086286710ef7c6ad32446b3f" name="a30f0a06e086286710ef7c6ad32446b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f0a06e086286710ef7c6ad32446b3f">&#9670;&nbsp;</a></span>purple_date_format_short()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * purple_date_format_short </td>
          <td>(</td>
          <td class="paramtype">const struct tm *&#160;</td>
          <td class="paramname"><em>tm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Formats a time into the user's preferred short date format.</p>
<p >The returned string is stored in a static buffer, so the result should be g_strdup()'d if it's going to be kept.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tm</td><td>The time to format, or <code>NULL</code> to use the current local time</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The date, formatted as per the user's settings. </dd></dl>

</div>
</div>
<a id="a7ee3c58ada020f55850d22846bc7405e" name="a7ee3c58ada020f55850d22846bc7405e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee3c58ada020f55850d22846bc7405e">&#9670;&nbsp;</a></span>purple_email_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean purple_email_is_valid </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Checks if the given email address is syntactically valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The email address to validate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the email address is syntactically correct. </dd></dl>

</div>
</div>
<a id="aa3195bd144559f99b38df3b9f8e18aa2" name="aa3195bd144559f99b38df3b9f8e18aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3195bd144559f99b38df3b9f8e18aa2">&#9670;&nbsp;</a></span>purple_escape_filename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * purple_escape_filename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Escapes filesystem-unfriendly characters from a filename</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to translate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting string. </dd></dl>

</div>
</div>
<a id="acba1636722a22f61b168d32a55ddff00" name="acba1636722a22f61b168d32a55ddff00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba1636722a22f61b168d32a55ddff00">&#9670;&nbsp;</a></span>purple_fd_get_ip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * purple_fd_get_ip </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the IP address from a socket file descriptor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The socket file descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The IP address, or <code>NULL</code> on error. </dd></dl>

</div>
</div>
<a id="a56bb14339565e284dbdb159b41e3526f" name="a56bb14339565e284dbdb159b41e3526f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56bb14339565e284dbdb159b41e3526f">&#9670;&nbsp;</a></span>purple_gai_strerror()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const gchar * purple_gai_strerror </td>
          <td>(</td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>errnum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return the UTF-8 version of gai_strerror(). It calls gai_strerror() then converts the result to UTF-8. This function is analogous to g_strerror().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errnum</td><td>The error code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The UTF-8 error message. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.4.0 </dd></dl>

</div>
</div>
<a id="a0bac424814d508b63ac7542e038e9e50" name="a0bac424814d508b63ac7542e038e9e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bac424814d508b63ac7542e038e9e50">&#9670;&nbsp;</a></span>purple_get_host_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const gchar * purple_get_host_name </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the host name of the machine. If it not possible to determine the host name, "localhost" is returned</p>
<p >@constreturn The hostname </p>

</div>
</div>
<a id="ad0eed4b5f40305734435dc5bda015f0f" name="ad0eed4b5f40305734435dc5bda015f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0eed4b5f40305734435dc5bda015f0f">&#9670;&nbsp;</a></span>purple_get_tzoff_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * purple_get_tzoff_str </td>
          <td>(</td>
          <td class="paramtype">const struct tm *&#160;</td>
          <td class="paramname"><em>tm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>iso</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets a string representation of the local timezone offset</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tm</td><td>The time to get the timezone for </td></tr>
    <tr><td class="paramname">iso</td><td>TRUE to format the offset according to ISO-8601, FALSE to not substitute 'Z' for 0 offset, and to not separate hours and minutes with a colon. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d971e649260624b05135855651e80f0" name="a5d971e649260624b05135855651e80f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d971e649260624b05135855651e80f0">&#9670;&nbsp;</a></span>purple_home_dir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const gchar * purple_home_dir </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the user's home directory.</p>
<dl class="section return"><dt>Returns</dt><dd>The user's home directory.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="util_8h.html#a15a391f407842384f56db8d381d44802">purple_user_dir()</a> </dd></dl>

</div>
</div>
<a id="a11ed8258810e98eb79ce9fb4727fabfa" name="a11ed8258810e98eb79ce9fb4727fabfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ed8258810e98eb79ce9fb4727fabfa">&#9670;&nbsp;</a></span>purple_ip_address_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean purple_ip_address_is_valid </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Checks if the given IP address is a syntactically valid IPv4 address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>The IP address to validate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the IP address is syntactically correct. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000064">Deprecated:</a></b></dt><dd>This function will be replaced with one that validates as either IPv4 or IPv6 in 3.0.0. If you don't want this, behavior, use one of the more specific functions. </dd></dl>

</div>
</div>
<a id="a78bb9f8fee426f3eb86481d684bea6a7" name="a78bb9f8fee426f3eb86481d684bea6a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78bb9f8fee426f3eb86481d684bea6a7">&#9670;&nbsp;</a></span>purple_ipv4_address_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean purple_ipv4_address_is_valid </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Checks if the given IP address is a syntactically valid IPv4 address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>The IP address to validate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the IP address is syntactically correct. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.6.0 </dd></dl>

</div>
</div>
<a id="a9375f51de090f20c8bf48f1ecb651e87" name="a9375f51de090f20c8bf48f1ecb651e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9375f51de090f20c8bf48f1ecb651e87">&#9670;&nbsp;</a></span>purple_ipv6_address_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean purple_ipv6_address_is_valid </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Checks if the given IP address is a syntactically valid IPv6 address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>The IP address to validate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the IP address is syntactically correct. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.6.0 </dd></dl>

</div>
</div>
<a id="a6622f65c9e85020aa07d3b0a8880b3e2" name="a6622f65c9e85020aa07d3b0a8880b3e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6622f65c9e85020aa07d3b0a8880b3e2">&#9670;&nbsp;</a></span>purple_markup_escape_text()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gchar * purple_markup_escape_text </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Escapes special characters in a plain-text string so they display correctly as HTML. For example, &amp; is replaced with &amp; and &lt; is replaced with &lt;</p>
<p >This is exactly the same as g_markup_escape_text(), except that it does not change ' to ' because ' is not a valid HTML 4 entity, and is displayed literally in IE7.</p>
<dl class="section since"><dt>Since</dt><dd>2.6.0 </dd></dl>

</div>
</div>
<a id="a450abc67be783d57310f023e9c3c36dd" name="a450abc67be783d57310f023e9c3c36dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450abc67be783d57310f023e9c3c36dd">&#9670;&nbsp;</a></span>purple_markup_extract_info_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean purple_markup_extract_info_field </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__PurpleNotifyUserInfo.html">PurpleNotifyUserInfo</a> *&#160;</td>
          <td class="paramname"><em>user_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>start_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>skip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>check_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>no_value_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>display_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>is_link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>link_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PurpleInfoFieldFormatCallback&#160;</td>
          <td class="paramname"><em>format_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Extracts a field of data from HTML.</p>
<p >This is a scary function. It used to be used for MSN and Yahoo prpls, but since those prpls have been removed, this is now deprecated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to parse. </td></tr>
    <tr><td class="paramname">len</td><td>The size of str. </td></tr>
    <tr><td class="paramname">user_info</td><td>The destination PurpleNotifyUserInfo to which the new field info should be added. </td></tr>
    <tr><td class="paramname">start_token</td><td>The beginning token. </td></tr>
    <tr><td class="paramname">skip</td><td>The number of characters to skip after the start token. </td></tr>
    <tr><td class="paramname">end_token</td><td>The ending token. </td></tr>
    <tr><td class="paramname">check_value</td><td>The value that the last character must meet. </td></tr>
    <tr><td class="paramname">no_value_token</td><td>The token indicating no value is given. </td></tr>
    <tr><td class="paramname">display_name</td><td>The short descriptive name to display for this token. </td></tr>
    <tr><td class="paramname">is_link</td><td>TRUE if this should be a link, or FALSE otherwise. </td></tr>
    <tr><td class="paramname">link_prefix</td><td>The prefix for the link. </td></tr>
    <tr><td class="paramname">format_cb</td><td>A callback to format the value before adding it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if successful, or FALSE otherwise. </dd></dl>

</div>
</div>
<a id="a35ebba86ab47dfd18b9a826814380dcf" name="a35ebba86ab47dfd18b9a826814380dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ebba86ab47dfd18b9a826814380dcf">&#9670;&nbsp;</a></span>purple_markup_find_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean purple_markup_find_tag </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GData **&#160;</td>
          <td class="paramname"><em>attributes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Finds an HTML tag matching the given name.</p>
<p >This locates an HTML tag's start and end, and stores its attributes in a GData hash table. The names of the attributes are lower-cased in the hash table, and the name of the tag is case insensitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The name of the tag </td></tr>
    <tr><td class="paramname">haystack</td><td>The null-delimited string to search in </td></tr>
    <tr><td class="paramname">start</td><td>A pointer to the start of the tag if found </td></tr>
    <tr><td class="paramname">end</td><td>A pointer to the end of the tag if found </td></tr>
    <tr><td class="paramname">attributes</td><td>The attributes, if the tag was found. This should be freed with g_datalist_clear(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the tag was found </dd></dl>

</div>
</div>
<a id="a8db1cbc21e8b24ed2fe2b6a026daa0d1" name="a8db1cbc21e8b24ed2fe2b6a026daa0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db1cbc21e8b24ed2fe2b6a026daa0d1">&#9670;&nbsp;</a></span>purple_markup_get_css_property()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * purple_markup_get_css_property </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns a newly allocated string containing the value of the CSS property specified in opt. The <em>style</em> argument is expected to point to a HTML inline CSS. The function will seek for the CSS property and return its value.</p>
<p >For example, purple_markup_get_css_property("direction:rtl;color:#dc4d1b;", "color") would return "#dc4d1b".</p>
<p >On error or if the requested property was not found, the function returns <code>NULL</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">style</td><td>A string containing the inline CSS text. </td></tr>
    <tr><td class="paramname">opt</td><td>The requested CSS property.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the requested CSS property. </dd></dl>

</div>
</div>
<a id="a1d57aec38cab8f689fe95078b2f6232d" name="a1d57aec38cab8f689fe95078b2f6232d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d57aec38cab8f689fe95078b2f6232d">&#9670;&nbsp;</a></span>purple_markup_get_tag_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * purple_markup_get_tag_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns a newly allocated string containing the name of the tag located at "tag". Tag is expected to point to a '&lt;', and contain a '&gt;' sometime after that. If there is no '&gt;' and the string is not NUL terminated, this function can be expected to segfault.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>The string starting a HTML tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing the name of the tag. </dd></dl>

</div>
</div>
<a id="af8f6a9384057b05e94fa66a3f6d63eda" name="af8f6a9384057b05e94fa66a3f6d63eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f6a9384057b05e94fa66a3f6d63eda">&#9670;&nbsp;</a></span>purple_markup_html_to_xhtml()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void purple_markup_html_to_xhtml </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>html</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>dest_xhtml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>dest_plain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Converts HTML markup to XHTML.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">html</td><td>The HTML markup. </td></tr>
    <tr><td class="paramname">dest_xhtml</td><td>The destination XHTML output. </td></tr>
    <tr><td class="paramname">dest_plain</td><td>The destination plain-text output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae7164e0420813156ed7d28f44c127c7" name="aae7164e0420813156ed7d28f44c127c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7164e0420813156ed7d28f44c127c7">&#9670;&nbsp;</a></span>purple_markup_is_rtl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean purple_markup_is_rtl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>html</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Check if the given HTML contains RTL text.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">html</td><td>The HTML text.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the text contains RTL text, FALSE otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.6.0 </dd></dl>

</div>
</div>
<a id="abc65ecc1aa13c2a455066d0dc65e54e5" name="abc65ecc1aa13c2a455066d0dc65e54e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc65ecc1aa13c2a455066d0dc65e54e5">&#9670;&nbsp;</a></span>purple_markup_linkify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * purple_markup_linkify </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds the necessary HTML code to turn URIs into HTML links in a string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to linkify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new string with all URIs surrounded in standard HTML <a href="whatever"></a> tags. You must g_free this string when finished with it. </dd></dl>

</div>
</div>
<a id="a7d46ee213ef2c0f4fdd7baa434f7a17b" name="a7d46ee213ef2c0f4fdd7baa434f7a17b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d46ee213ef2c0f4fdd7baa434f7a17b">&#9670;&nbsp;</a></span>purple_markup_slice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * purple_markup_slice </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns a newly allocated substring of the HTML UTF-8 string "str". The markup is preserved such that the substring will have the same formatting as original string, even though some tags may have been opened before "x", or may close after "y". All open tags are closed at the end of the returned string, in the proper order.</p>
<p >Note that x and y are in character offsets, not byte offsets, and are offsets into an unformatted version of str. Because of this, this function may be sensitive to changes in GtkIMHtml and may break when used with other UI's. libpurple users are encouraged to report and work out any problems encountered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The input NUL terminated, HTML, UTF-8 (or ASCII) string. </td></tr>
    <tr><td class="paramname">x</td><td>The character offset into an unformatted version of str to begin at. </td></tr>
    <tr><td class="paramname">y</td><td>The character offset (into an unformatted vesion of str) of one past the last character to include in the slice.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The HTML slice of string, with all formatting retained. </dd></dl>

</div>
</div>
<a id="a0f02bb7e180bb04fb74c8f39564902ee" name="a0f02bb7e180bb04fb74c8f39564902ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f02bb7e180bb04fb74c8f39564902ee">&#9670;&nbsp;</a></span>purple_markup_strip_html()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * purple_markup_strip_html </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Strips HTML tags from a string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to strip HTML from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new string without HTML. You must g_free this string when finished with it. </dd></dl>

</div>
</div>
<a id="a10086c08db5585062550a33647597237" name="a10086c08db5585062550a33647597237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10086c08db5585062550a33647597237">&#9670;&nbsp;</a></span>purple_markup_unescape_entity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * purple_markup_unescape_entity </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns a constant string of the character representation of the HTML entity pointed to by <em>text</em>. For example, purple_markup_unescape_entity("&amp;amp;") will return "&amp;". The <em>text</em> variable is expected to point to an '&amp;', the first character of the entity. If given an unrecognized entity, the function returns <code>NULL</code>.</p>
<p >Note that this function, unlike <a class="el" href="util_8h.html#af562f060e55fbd17d4ec4630a040b52a">purple_unescape_html()</a>, does not search the string for the entity, does not replace the entity, and does not return a newly allocated string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>A string containing an HTML entity. </td></tr>
    <tr><td class="paramname">length</td><td>If not <code>NULL</code>, the string length of the entity is stored in this location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant string containing the character representation of the given entity. </dd></dl>

</div>
</div>
<a id="acaa2e10648a5c61a3af6c8a1c3145301" name="acaa2e10648a5c61a3af6c8a1c3145301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa2e10648a5c61a3af6c8a1c3145301">&#9670;&nbsp;</a></span>purple_menu_action_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void purple_menu_action_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__PurpleMenuAction.html">PurpleMenuAction</a> *&#160;</td>
          <td class="paramname"><em>act</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Frees a PurpleMenuAction</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">act</td><td>The PurpleMenuAction to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b0ee88eda377ea99b2dcae650a35f10" name="a9b0ee88eda377ea99b2dcae650a35f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0ee88eda377ea99b2dcae650a35f10">&#9670;&nbsp;</a></span>purple_menu_action_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__PurpleMenuAction.html">PurpleMenuAction</a> * purple_menu_action_new </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PurpleCallback&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpointer&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GList *&#160;</td>
          <td class="paramname"><em>children</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new PurpleMenuAction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>The text label to display for this action. </td></tr>
    <tr><td class="paramname">callback</td><td>The function to be called when the action is used on the selected item. </td></tr>
    <tr><td class="paramname">data</td><td>Additional data to be passed to the callback. </td></tr>
    <tr><td class="paramname">children</td><td>A GList of PurpleMenuActions to be added as a submenu of the action. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The PurpleMenuAction. </dd></dl>

</div>
</div>
<a id="a91ce7b8c3dcabfde08353c85236dd07f" name="a91ce7b8c3dcabfde08353c85236dd07f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ce7b8c3dcabfde08353c85236dd07f">&#9670;&nbsp;</a></span>purple_message_meify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean purple_message_meify </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Checks for messages starting (post-HTML) with "/me ", including the space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The message to check </td></tr>
    <tr><td class="paramname">len</td><td>The message length, or -1</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if it starts with "/me ", and it has been removed, otherwise FALSE </dd></dl>

</div>
</div>
<a id="a85db5a9404bd45b00e3e1559b492ee1e" name="a85db5a9404bd45b00e3e1559b492ee1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85db5a9404bd45b00e3e1559b492ee1e">&#9670;&nbsp;</a></span>purple_mime_decode_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * purple_mime_decode_field </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Converts a MIME header field string back to its readable equivalent according to RFC 2047. Basically, a header is plain ASCII and can contain any number of sections called "encoded-words." The format of an encoded word is =?ISO-8859-1?Q?Keld_J=F8rn_Simonsen?= =? designates the beginning of the encoded-word ?= designates the end of the encoded-word</p>
<p >An encoded word is segmented into three pieces by the use of a question mark. The first piece is the character set, the second piece is the encoding, and the third piece is the encoded text.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The ASCII string, possibly containing any number of encoded-word sections.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string, with any encoded-word sections decoded and converted to UTF-8. Must be g_free'd when no longer needed. </dd></dl>

</div>
</div>
<a id="a5015be993336467f21123a4638c658fa" name="a5015be993336467f21123a4638c658fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5015be993336467f21123a4638c658fa">&#9670;&nbsp;</a></span>purple_mkstemp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE * purple_mkstemp </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>binary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a temporary file and returns a file pointer to it.</p>
<p >This is like mkstemp(), but returns a file pointer and uses a pre-set template. It uses the semantics of tempnam() for the directory to use and allocates the space for the file path.</p>
<p >The caller is responsible for closing the file and removing it when done, as well as freeing the space pointed to by <em>path</em> with g_free().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The returned path to the temp file. </td></tr>
    <tr><td class="paramname">binary</td><td>Text or binary, for platforms where it matters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A file pointer to the temporary file, or <code>NULL</code> on failure. </dd></dl>

</div>
</div>
<a id="a59eedcc9bcce5d3eb2d4222b7bfd7cf8" name="a59eedcc9bcce5d3eb2d4222b7bfd7cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59eedcc9bcce5d3eb2d4222b7bfd7cf8">&#9670;&nbsp;</a></span>purple_normalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * purple_normalize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="account_8h.html#ab9db46cb0fe2619a85a173379c1ae053">PurpleAccount</a> *&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Normalizes a string, so that it is suitable for comparison.</p>
<p >The returned string will point to a static buffer, so if the string is intended to be kept long-term, you <em>must</em> g_strdup() it. Also, calling normalize() twice in the same line will lead to problems.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">account</td><td>The account the string belongs to, or NULL if you do not know the account. If you use NULL, the string will still be normalized, but if the PRPL uses a custom normalization function then the string may not be normalized correctly. </td></tr>
    <tr><td class="paramname">str</td><td>The string to normalize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the normalized version stored in a static buffer. </dd></dl>

</div>
</div>
<a id="a34f0d41c22171b4bc05974b6f649e0cc" name="a34f0d41c22171b4bc05974b6f649e0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f0d41c22171b4bc05974b6f649e0cc">&#9670;&nbsp;</a></span>purple_normalize_nocase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * purple_normalize_nocase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="account_8h.html#ab9db46cb0fe2619a85a173379c1ae053">PurpleAccount</a> *&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Normalizes a string, so that it is suitable for comparison.</p>
<p >This is one possible implementation for the PRPL callback function "normalize." It returns a lowercase and UTF-8 normalized version of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">account</td><td>The account the string belongs to. </td></tr>
    <tr><td class="paramname">str</td><td>The string to normalize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the normalized version stored in a static buffer. </dd></dl>

</div>
</div>
<a id="a7ee3a1f4935e0bf32bb523fc6e30f22e" name="a7ee3a1f4935e0bf32bb523fc6e30f22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee3a1f4935e0bf32bb523fc6e30f22e">&#9670;&nbsp;</a></span>purple_print_utf8_to_console()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void purple_print_utf8_to_console </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>filestream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Prints a UTF-8 message to the given file stream. The function tries to convert the UTF-8 message to user's locale. If this is not possible, the original UTF-8 text will be printed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filestream</td><td>The file stream (e.g. STDOUT or STDERR) </td></tr>
    <tr><td class="paramname">message</td><td>The message to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1a122edb33c83912b96f01d7f10dd35" name="aa1a122edb33c83912b96f01d7f10dd35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a122edb33c83912b96f01d7f10dd35">&#9670;&nbsp;</a></span>purple_program_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean purple_program_is_valid </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>program</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Checks if the given program name is valid and executable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td>The file name of the application.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the program is runable. </dd></dl>

</div>
</div>
<a id="a5a863435e070cf060e73e9700b9a39c3" name="a5a863435e070cf060e73e9700b9a39c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a863435e070cf060e73e9700b9a39c3">&#9670;&nbsp;</a></span>purple_quotedp_decode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guchar * purple_quotedp_decode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize *&#160;</td>
          <td class="paramname"><em>ret_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Converts a quoted printable string back to its readable equivalent. What is a quoted printable string, you ask? It's an encoding used to transmit binary data as ASCII. It's intended purpose is to send emails containing non-ASCII characters. Wikipedia has a pretty good explanation. Also see RFC 2045.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The quoted printable ASCII string to convert to raw data. </td></tr>
    <tr><td class="paramname">ret_len</td><td>The length of the returned data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The readable string. Must be g_free'd when no longer needed. </dd></dl>

</div>
</div>
<a id="aad5141ad67081cb08d507d3e8fbc857b" name="aad5141ad67081cb08d507d3e8fbc857b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5141ad67081cb08d507d3e8fbc857b">&#9670;&nbsp;</a></span>purple_restore_default_signal_handlers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void purple_restore_default_signal_handlers </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Restore default signal handlers for signals which might reasonably have handlers. This should be called by a fork()'d child process, since child processes inherit the handlers of the parent. </p>

</div>
</div>
<a id="a7853bf4f38acfb446c24dd009c9a5e4d" name="a7853bf4f38acfb446c24dd009c9a5e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7853bf4f38acfb446c24dd009c9a5e4d">&#9670;&nbsp;</a></span>purple_running_gnome()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean purple_running_gnome </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Check if running GNOME.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if running GNOME, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="a653222fd4dcd584737348f001f22d0ed" name="a653222fd4dcd584737348f001f22d0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653222fd4dcd584737348f001f22d0ed">&#9670;&nbsp;</a></span>purple_running_kde()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean purple_running_kde </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Check if running KDE.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if running KDE, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="aa699b3ba92c849b29ed0c43b9e2b6026" name="aa699b3ba92c849b29ed0c43b9e2b6026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa699b3ba92c849b29ed0c43b9e2b6026">&#9670;&nbsp;</a></span>purple_running_osx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean purple_running_osx </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Check if running OS X.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if running OS X, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="afad6976c14e906f47cdd7799c4d73cf6" name="afad6976c14e906f47cdd7799c4d73cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad6976c14e906f47cdd7799c4d73cf6">&#9670;&nbsp;</a></span>purple_socket_get_family()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int purple_socket_get_family </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the address family of a socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The socket file descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The address family of the socket (AF_INET, AF_INET6, etc) or -1 on error. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.7.0 </dd></dl>

</div>
</div>
<a id="ad1d917bc74dd82bb19f0f129f1c6be69" name="ad1d917bc74dd82bb19f0f129f1c6be69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d917bc74dd82bb19f0f129f1c6be69">&#9670;&nbsp;</a></span>purple_socket_speaks_ipv4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean purple_socket_speaks_ipv4 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns TRUE if a socket is capable of speaking IPv4.</p>
<p >This is the case for IPv4 sockets and, on some systems, IPv6 sockets (due to the IPv4-mapped address functionality).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The socket file descriptor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if a socket can speak IPv4. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.7.0 </dd></dl>

</div>
</div>
<a id="a808e5e8dd49120d79060a70504ed1924" name="a808e5e8dd49120d79060a70504ed1924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808e5e8dd49120d79060a70504ed1924">&#9670;&nbsp;</a></span>purple_str_add_cr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * purple_str_add_cr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Ensures that all linefeeds have a matching carriage return.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The source string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string with carriage returns. </dd></dl>

</div>
</div>
<a id="ad6cc259b46deb63585977e629b5ef456" name="ad6cc259b46deb63585977e629b5ef456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6cc259b46deb63585977e629b5ef456">&#9670;&nbsp;</a></span>purple_str_binary_to_ascii()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * purple_str_binary_to_ascii </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>binary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Converts a binary string into a NUL terminated ascii string, replacing nonascii characters and characters below SPACE (including NUL) into \xyy, where yy are two hex digits. Also backslashes are changed into two backslashes (\\). The returned, newly allocated string can be outputted to the console, and must be g_free()d.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binary</td><td>A string of random data, possibly with embedded NULs and such. </td></tr>
    <tr><td class="paramname">len</td><td>The length in bytes of the input string. Must not be 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated ASCIIZ string. </dd></dl>

</div>
</div>
<a id="affcb029e51b1ec4e178c2cd983f39f65" name="affcb029e51b1ec4e178c2cd983f39f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affcb029e51b1ec4e178c2cd983f39f65">&#9670;&nbsp;</a></span>purple_str_has_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean purple_str_has_prefix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compares two strings to see if the first contains the second as a proper prefix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to check. </td></tr>
    <tr><td class="paramname">p</td><td>The prefix in question.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if p is a prefix of s, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="aa2ac2e13331d7abee380f056b2887d1f" name="aa2ac2e13331d7abee380f056b2887d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ac2e13331d7abee380f056b2887d1f">&#9670;&nbsp;</a></span>purple_str_has_suffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean purple_str_has_suffix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compares two strings to see if the second is a proper suffix of the first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to check. </td></tr>
    <tr><td class="paramname">x</td><td>The suffix in question.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if x is a a suffix of s, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a49247a6802f7787754d47ede44ecf474" name="a49247a6802f7787754d47ede44ecf474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49247a6802f7787754d47ede44ecf474">&#9670;&nbsp;</a></span>purple_str_seconds_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * purple_str_seconds_to_string </td>
          <td>(</td>
          <td class="paramtype">guint&#160;</td>
          <td class="paramname"><em>sec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Converts seconds into a human-readable form.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sec</td><td>The seconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A human-readable form, containing days, hours, minutes, and seconds. </dd></dl>

</div>
</div>
<a id="ab4bca165934439c14f0b6003164cf6bd" name="ab4bca165934439c14f0b6003164cf6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4bca165934439c14f0b6003164cf6bd">&#9670;&nbsp;</a></span>purple_str_size_to_units()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * purple_str_size_to_units </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns a string representing a filesize in the appropriate units (MB, KB, GB, etc.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string in units form. This must be freed. </dd></dl>

</div>
</div>
<a id="ab00d237784cfa8b583bde380f5cb041c" name="ab00d237784cfa8b583bde380f5cb041c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00d237784cfa8b583bde380f5cb041c">&#9670;&nbsp;</a></span>purple_str_strip_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void purple_str_strip_char </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>thechar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Strips all instances of the given character from the given string. The string is modified in place. This is useful for stripping new line characters, for example.</p>
<p >Example usage: purple_str_strip_char(my_dumb_string, '<br  />
');</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to strip characters from. </td></tr>
    <tr><td class="paramname">thechar</td><td>The character to strip from the given string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4881fba04ce7ff9ccf514c7b7214f59" name="ab4881fba04ce7ff9ccf514c7b7214f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4881fba04ce7ff9ccf514c7b7214f59">&#9670;&nbsp;</a></span>purple_str_to_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t purple_str_to_time </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>utc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct tm *&#160;</td>
          <td class="paramname"><em>tm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>tz_off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Parses a timestamp in jabber, ISO8601, or MM/DD/YYYY format and returns a time_t.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestamp</td><td>The timestamp </td></tr>
    <tr><td class="paramname">utc</td><td>Assume UTC if no timezone specified </td></tr>
    <tr><td class="paramname">tm</td><td>If not <code>NULL</code>, the caller can get a copy of the struct tm used to calculate the time_t return value. </td></tr>
    <tr><td class="paramname">tz_off</td><td>If not <code>NULL</code>, the caller can get a copy of the timezone offset (from UTC) used to calculate the time_t return value. Note: Zero is a valid offset. As such, the value of the macro <code>PURPLE_NO_TZ_OFF</code> indicates no offset was specified (which means that the local timezone was used in the calculation). </td></tr>
    <tr><td class="paramname">rest</td><td>If not <code>NULL</code>, the caller can get a pointer to the part of <em>timestamp</em> left over after parsing is completed, if it's not the end of <em>timestamp</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A time_t. </dd></dl>

</div>
</div>
<a id="a0d0fc428a02154bb117e8419ebd2c828" name="a0d0fc428a02154bb117e8419ebd2c828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0fc428a02154bb117e8419ebd2c828">&#9670;&nbsp;</a></span>purple_strcasereplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gchar * purple_strcasereplace </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>replacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Given a string, this replaces one substring with another ignoring case and returns a newly allocated string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The string from which to replace stuff. </td></tr>
    <tr><td class="paramname">delimiter</td><td>The substring you want replaced. </td></tr>
    <tr><td class="paramname">replacement</td><td>The substring you want inserted in place of the delimiting substring.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new string, after performing the substitution. free this with g_free(). </dd></dl>

</div>
</div>
<a id="a3ebaac4388e025c69de474f5db0a30b2" name="a3ebaac4388e025c69de474f5db0a30b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ebaac4388e025c69de474f5db0a30b2">&#9670;&nbsp;</a></span>purple_strcasestr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * purple_strcasestr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This is like strstr, except that it ignores ASCII case in searching for the substring.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>The string to search in. </td></tr>
    <tr><td class="paramname">needle</td><td>The substring to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the location of the substring if found, or NULL if not </dd></dl>

</div>
</div>
<a id="abc484fa0cdfa1a9b8ea14c7e84eb1882" name="abc484fa0cdfa1a9b8ea14c7e84eb1882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc484fa0cdfa1a9b8ea14c7e84eb1882">&#9670;&nbsp;</a></span>purple_strdup_withhtml()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gchar * purple_strdup_withhtml </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Duplicates a string and replaces all newline characters from the source string with HTML linebreaks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new string. Must be g_free'd by the caller. </dd></dl>

</div>
</div>
<a id="a323ebbe4227c69bbbda9d6d51a551700" name="a323ebbe4227c69bbbda9d6d51a551700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323ebbe4227c69bbbda9d6d51a551700">&#9670;&nbsp;</a></span>purple_strequal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean purple_strequal </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Tests two strings for equality.</p>
<p >Unlike strcmp(), this function will not crash if one or both of the strings are <code>NULL</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>A string </td></tr>
    <tr><td class="paramname">right</td><td>A string to compare with left</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>TRUE</code> if the strings are the same, else <code>FALSE</code>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.6.0 </dd></dl>

</div>
</div>
<a id="af5f899a78bd889d73319155c6ba8b671" name="af5f899a78bd889d73319155c6ba8b671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f899a78bd889d73319155c6ba8b671">&#9670;&nbsp;</a></span>purple_strreplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gchar * purple_strreplace </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>replacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Given a string, this replaces one substring with another and returns a newly allocated string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The string from which to replace stuff. </td></tr>
    <tr><td class="paramname">delimiter</td><td>The substring you want replaced. </td></tr>
    <tr><td class="paramname">replacement</td><td>The substring you want inserted in place of the delimiting substring.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new string, after performing the substitution. free this with g_free(). </dd></dl>

</div>
</div>
<a id="a07cdffae48a389e72ea3e6688d34c3d4" name="a07cdffae48a389e72ea3e6688d34c3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07cdffae48a389e72ea3e6688d34c3d4">&#9670;&nbsp;</a></span>purple_text_strip_mnemonic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * purple_text_strip_mnemonic </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Removes the underscore characters from a string used identify the mnemonic character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The string to strip</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stripped string </dd></dl>

</div>
</div>
<a id="a5921f52e7574a3fe170f277322202f1a" name="a5921f52e7574a3fe170f277322202f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5921f52e7574a3fe170f277322202f1a">&#9670;&nbsp;</a></span>purple_time_build()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t purple_time_build </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>year</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>month</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>day</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Builds a time_t from the supplied information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">year</td><td>The year. </td></tr>
    <tr><td class="paramname">month</td><td>The month. </td></tr>
    <tr><td class="paramname">day</td><td>The day. </td></tr>
    <tr><td class="paramname">hour</td><td>The hour. </td></tr>
    <tr><td class="paramname">min</td><td>The minute. </td></tr>
    <tr><td class="paramname">sec</td><td>The second.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A time_t. </dd></dl>

</div>
</div>
<a id="a3e5cc49e811038c29d40ae36a1f305f7" name="a3e5cc49e811038c29d40ae36a1f305f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5cc49e811038c29d40ae36a1f305f7">&#9670;&nbsp;</a></span>purple_time_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * purple_time_format </td>
          <td>(</td>
          <td class="paramtype">const struct tm *&#160;</td>
          <td class="paramname"><em>tm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Formats a time into the user's preferred time format.</p>
<p >The returned string is stored in a static buffer, so the result should be g_strdup()'d if it's going to be kept.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tm</td><td>The time to format, or <code>NULL</code> to use the current local time</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The time, formatted as per the user's settings. </dd></dl>

</div>
</div>
<a id="a245293bb6477ff6032c35ecf9484a527" name="a245293bb6477ff6032c35ecf9484a527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245293bb6477ff6032c35ecf9484a527">&#9670;&nbsp;</a></span>purple_unescape_filename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * purple_unescape_filename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Does the reverse of purple_escape_filename</p>
<p >This will change hex codes and such to their ascii equivalents.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to translate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting string. </dd></dl>

</div>
</div>
<a id="af562f060e55fbd17d4ec4630a040b52a" name="af562f060e55fbd17d4ec4630a040b52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af562f060e55fbd17d4ec4630a040b52a">&#9670;&nbsp;</a></span>purple_unescape_html()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * purple_unescape_html </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>html</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Unescapes HTML entities to their literal characters and converts "&lt;br&gt;" to "\n". See <a class="el" href="util_8h.html#a9826f3952f9cb29e1f8da65221402cc8">purple_unescape_text()</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">html</td><td>The string in which to unescape any HTML entities</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The text with HTML entities literalized. You must g_free this string when finished with it.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="util_8h.html#a9826f3952f9cb29e1f8da65221402cc8">purple_unescape_text()</a> </dd></dl>

</div>
</div>
<a id="a9826f3952f9cb29e1f8da65221402cc8" name="a9826f3952f9cb29e1f8da65221402cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9826f3952f9cb29e1f8da65221402cc8">&#9670;&nbsp;</a></span>purple_unescape_text()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * purple_unescape_text </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Unescapes HTML entities to their literal characters in the text. For example "&amp;amp;" is replaced by '&amp;' and so on. Also converts numerical entities (e.g. "&amp;#38;" is also '&amp;').</p>
<p >This function currently supports the following named entities: "&amp;amp;", "&amp;lt;", "&amp;gt;", "&amp;copy;", "&amp;quot;", "&amp;reg;", "&amp;apos;"</p>
<p ><a class="el" href="util_8h.html#af562f060e55fbd17d4ec4630a040b52a">purple_unescape_html()</a> is similar, but also converts "&lt;br&gt;" into "\n".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The string in which to unescape any HTML entities</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The text with HTML entities literalized. You must g_free this string when finished with it.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="util_8h.html#af562f060e55fbd17d4ec4630a040b52a">purple_unescape_html()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.7.0 </dd></dl>

</div>
</div>
<a id="ad2705811cc9c0f6503444dc1f43c3c90" name="ad2705811cc9c0f6503444dc1f43c3c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2705811cc9c0f6503444dc1f43c3c90">&#9670;&nbsp;</a></span>purple_uri_escape_for_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * purple_uri_escape_for_open </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>unescaped</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function escapes any characters that might be interpreted by the shell when executing a program to open a URI on some systems.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unescaped</td><td>The unescaped URI.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated string with any shell metacharacters replaced with their escaped equivalents. </dd></dl>

</div>
</div>
<a id="a986d3ca17265c46fbf117ff40f2e28d0" name="a986d3ca17265c46fbf117ff40f2e28d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a986d3ca17265c46fbf117ff40f2e28d0">&#9670;&nbsp;</a></span>purple_uri_list_extract_filenames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GList * purple_uri_list_extract_filenames </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>uri_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function extracts a list of filenames from a "text/uri-list" string. It was "borrowed" from gnome_uri_list_extract_filenames</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uri_list</td><td>A uri-list in the standard format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GList containing strings allocated with g_malloc that contain the filenames in the uri-list. Note that unlike <a class="el" href="util_8h.html#ac88b47d173e5d05dd686fb7400685ef5">purple_uri_list_extract_uris()</a> function, this will discard any non-file uri from the result value. </dd></dl>

</div>
</div>
<a id="ac88b47d173e5d05dd686fb7400685ef5" name="ac88b47d173e5d05dd686fb7400685ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88b47d173e5d05dd686fb7400685ef5">&#9670;&nbsp;</a></span>purple_uri_list_extract_uris()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GList * purple_uri_list_extract_uris </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>uri_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function extracts a list of URIs from the a "text/uri-list" string. It was "borrowed" from gnome_uri_list_extract_uris</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uri_list</td><td>An uri-list in the standard format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GList containing strings allocated with g_malloc that have been splitted from uri-list. </dd></dl>

</div>
</div>
<a id="a6c9d6b81c1e831124a0d652e44610e8c" name="a6c9d6b81c1e831124a0d652e44610e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9d6b81c1e831124a0d652e44610e8c">&#9670;&nbsp;</a></span>purple_url_decode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * purple_url_decode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Decodes a URL into a plain string.</p>
<p >This will change hex codes and such to their ascii equivalents.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to translate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting string. </dd></dl>

</div>
</div>
<a id="ae609f88e8b3214d18b7e5aa3fa00288f" name="ae609f88e8b3214d18b7e5aa3fa00288f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae609f88e8b3214d18b7e5aa3fa00288f">&#9670;&nbsp;</a></span>purple_url_encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * purple_url_encode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Encodes a URL into an escaped string.</p>
<p >This will change non-alphanumeric characters to hex codes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to translate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting string. </dd></dl>

</div>
</div>
<a id="a567d8d62b84abbbb74fc69a91041342e" name="a567d8d62b84abbbb74fc69a91041342e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567d8d62b84abbbb74fc69a91041342e">&#9670;&nbsp;</a></span>purple_url_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean purple_url_parse </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ret_host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ret_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ret_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ret_user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ret_passwd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Parses a URL, returning its host, port, file path, username and password.</p>
<p >The returned data must be freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>The URL to parse. </td></tr>
    <tr><td class="paramname">ret_host</td><td>The returned host. </td></tr>
    <tr><td class="paramname">ret_port</td><td>The returned port. </td></tr>
    <tr><td class="paramname">ret_path</td><td>The returned path. </td></tr>
    <tr><td class="paramname">ret_user</td><td>The returned username. </td></tr>
    <tr><td class="paramname">ret_passwd</td><td>The returned password. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15a391f407842384f56db8d381d44802" name="a15a391f407842384f56db8d381d44802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a391f407842384f56db8d381d44802">&#9670;&nbsp;</a></span>purple_user_dir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * purple_user_dir </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the purple settings directory in the user's home directory. This is usually ~/.purple</p>
<dl class="section return"><dt>Returns</dt><dd>The purple settings directory.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="util_8h.html#a5d971e649260624b05135855651e80f0">purple_home_dir()</a> </dd></dl>

</div>
</div>
<a id="af719fe21cd38649afac508a293ef0c9e" name="af719fe21cd38649afac508a293ef0c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af719fe21cd38649afac508a293ef0c9e">&#9670;&nbsp;</a></span>purple_utf8_has_word()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean purple_utf8_has_word </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Case insensitive search for a word in a string. The needle string must be contained in the haystack string and not be immediately preceded or immediately followed by another alpha-numeric character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>The string to search in. </td></tr>
    <tr><td class="paramname">needle</td><td>The substring to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if haystack has the word, otherwise FALSE </dd></dl>

</div>
</div>
<a id="a548f23866a5382b1b18e5d589b665364" name="a548f23866a5382b1b18e5d589b665364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548f23866a5382b1b18e5d589b665364">&#9670;&nbsp;</a></span>purple_utf8_ncr_decode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * purple_utf8_ncr_decode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Given a string, this replaces any numerical character references in that string with the corresponding actual utf-8 substrings, and returns a newly allocated string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The string which might contain numerical character references.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new string, with numerical character references replaced with actual utf-8, free this with g_free(). </dd></dl>

</div>
</div>
<a id="a3f7779a8687ca4379e40f96479d2c38b" name="a3f7779a8687ca4379e40f96479d2c38b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7779a8687ca4379e40f96479d2c38b">&#9670;&nbsp;</a></span>purple_utf8_ncr_encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * purple_utf8_ncr_encode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Given a string, this replaces any utf-8 substrings in that string with the corresponding numerical character reference, and returns a newly allocated string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The string which might contain utf-8 substrings</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new string, with utf-8 replaced with numerical character references, free this with g_free() </dd></dl>

</div>
</div>
<a id="a2dd46ddcde4a365439cef7f0ad46d743" name="a2dd46ddcde4a365439cef7f0ad46d743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd46ddcde4a365439cef7f0ad46d743">&#9670;&nbsp;</a></span>purple_utf8_salvage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gchar * purple_utf8_salvage </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Salvages the valid UTF-8 characters from a string, replacing any invalid characters with a filler character (currently hardcoded to '?').</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The source string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A valid UTF-8 string. </dd></dl>

</div>
</div>
<a id="a3359c4de824a595855eec37c7503e2be" name="a3359c4de824a595855eec37c7503e2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3359c4de824a595855eec37c7503e2be">&#9670;&nbsp;</a></span>purple_utf8_strcasecmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int purple_utf8_strcasecmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compares two UTF-8 strings case-insensitively. This comparison is more expensive than a simple g_utf8_collate() comparison because it calls g_utf8_casefold() on each string, which allocates new strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first string. </td></tr>
    <tr><td class="paramname">b</td><td>The second string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if <em>is</em> less than <em>b</em>. 0 if <em>is</em> equal to <em>b</em>. 1 if <em>is</em> greater than <em>b</em>. </dd></dl>

</div>
</div>
<a id="a8fcfa92cab47de233cfc4584c14f4e9e" name="a8fcfa92cab47de233cfc4584c14f4e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fcfa92cab47de233cfc4584c14f4e9e">&#9670;&nbsp;</a></span>purple_utf8_strftime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * purple_utf8_strftime </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct tm *&#160;</td>
          <td class="paramname"><em>tm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Formats a time into the specified format.</p>
<p >This is essentially strftime(), but it has a static buffer and handles the UTF-8 conversion for the caller.</p>
<p >This function also provides the GNU z formatter if the underlying C library doesn't. However, the format string parser is very naive, which means that conversions specifiers to z cannot be guaranteed. The GNU strftime(3) man page describes z as: 'The time-zone as hour offset from GMT. Required to emit RFC822-conformant dates (using "%a, %d %b %Y %H:%M:%S %z"). (GNU)'</p>
<p >On Windows, this function also converts the results for Z from a timezone name (as returned by the system strftime() Z format string) to a timezone abbreviation (as is the case on Unix). As with z, conversion specifiers should not be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>The format string, in UTF-8 </td></tr>
    <tr><td class="paramname">tm</td><td>The time to format, or <code>NULL</code> to use the current local time</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The formatted time, in UTF-8.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><em>format</em> is required to be in UTF-8. This differs from strftime(), where the format is provided in the locale charset. </dd></dl>

</div>
</div>
<a id="a95b981dc639dbf50845cc70214fbc123" name="a95b981dc639dbf50845cc70214fbc123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b981dc639dbf50845cc70214fbc123">&#9670;&nbsp;</a></span>purple_utf8_strip_unprintables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gchar * purple_utf8_strip_unprintables </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Removes unprintable characters from a UTF-8 string. These characters (in particular low-ASCII characters) are invalid in XML 1.0 and thus are not allowed in XMPP and are rejected by libxml2 by default.</p>
<p >The returned string must be freed by the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A valid UTF-8 string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated UTF-8 string without the unprintable characters. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.6.0 </dd></dl>

</div>
</div>
<a id="aaf23a59705602095dac13684628b102e" name="aaf23a59705602095dac13684628b102e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf23a59705602095dac13684628b102e">&#9670;&nbsp;</a></span>purple_utf8_try_convert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gchar * purple_utf8_try_convert </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attempts to convert a string to UTF-8 from an unknown encoding.</p>
<p >This function checks the locale and tries sane defaults.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The source string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The UTF-8 string, or <code>NULL</code> if it could not be converted. </dd></dl>

</div>
</div>
<a id="afe273c36968ff02e8394bbebab791341" name="afe273c36968ff02e8394bbebab791341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe273c36968ff02e8394bbebab791341">&#9670;&nbsp;</a></span>purple_util_chrreplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void purple_util_chrreplace </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>replacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Given a string, this replaces all instances of one character with another. This happens inline (the original string IS modified).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The string from which to replace stuff. </td></tr>
    <tr><td class="paramname">delimiter</td><td>The character you want replaced. </td></tr>
    <tr><td class="paramname">replacement</td><td>The character you want inserted in place of the delimiting character. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a8bb5e1415159f9f6feff94e7703cf2" name="a2a8bb5e1415159f9f6feff94e7703cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a8bb5e1415159f9f6feff94e7703cf2">&#9670;&nbsp;</a></span>purple_util_fetch_url_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void purple_util_fetch_url_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__PurpleUtilFetchUrlData.html">PurpleUtilFetchUrlData</a> *&#160;</td>
          <td class="paramname"><em>url_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Cancel a pending URL request started with either <a class="el" href="util_8h.html#a82426f03bee7c928390a1d299b752db4">purple_util_fetch_url_request()</a> or <a class="el" href="util_8h.html#a3a99b02ce53153ac1942b39107dfc26a">purple_util_fetch_url()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url_data</td><td>The data returned when you initiated the URL fetch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82426f03bee7c928390a1d299b752db4" name="a82426f03bee7c928390a1d299b752db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82426f03bee7c928390a1d299b752db4">&#9670;&nbsp;</a></span>purple_util_fetch_url_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__PurpleUtilFetchUrlData.html">PurpleUtilFetchUrlData</a> * purple_util_fetch_url_request </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>full</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>user_agent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>http11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>include_headers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="util_8h.html#a9ad47dea3dfd7e801e022b472c5bf6bc">PurpleUtilFetchUrlCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpointer&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Fetches the data from a URL, and passes it to a callback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>The URL. </td></tr>
    <tr><td class="paramname">full</td><td>TRUE if this is the full URL, or FALSE if it's a partial URL. </td></tr>
    <tr><td class="paramname">user_agent</td><td>The user agent field to use, or NULL. </td></tr>
    <tr><td class="paramname">http11</td><td>TRUE if HTTP/1.1 should be used to download the file. </td></tr>
    <tr><td class="paramname">request</td><td>A HTTP request to send to the server instead of the standard GET </td></tr>
    <tr><td class="paramname">include_headers</td><td>If TRUE, include the HTTP headers in the response. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback function. </td></tr>
    <tr><td class="paramname">data</td><td>The user data to pass to the callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a165fb9bb6da5fc702751e2e9cb14a6e7" name="a165fb9bb6da5fc702751e2e9cb14a6e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a165fb9bb6da5fc702751e2e9cb14a6e7">&#9670;&nbsp;</a></span>purple_util_fetch_url_request_data_len_with_account()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__PurpleUtilFetchUrlData.html">PurpleUtilFetchUrlData</a> * purple_util_fetch_url_request_data_len_with_account </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="account_8h.html#ab9db46cb0fe2619a85a173379c1ae053">PurpleAccount</a> *&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>full</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>user_agent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>http11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>request_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>include_headers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&#160;</td>
          <td class="paramname"><em>max_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="util_8h.html#a9ad47dea3dfd7e801e022b472c5bf6bc">PurpleUtilFetchUrlCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Fetches the data from a URL, and passes it to a callback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">account</td><td>The account for which the request is needed, or NULL. </td></tr>
    <tr><td class="paramname">url</td><td>The URL. </td></tr>
    <tr><td class="paramname">full</td><td>TRUE if this is the full URL, or FALSE if it's a partial URL. </td></tr>
    <tr><td class="paramname">user_agent</td><td>The user agent field to use, or NULL. </td></tr>
    <tr><td class="paramname">http11</td><td>TRUE if HTTP/1.1 should be used to download the file. </td></tr>
    <tr><td class="paramname">request</td><td>A HTTP request to send to the server instead of the standard GET </td></tr>
    <tr><td class="paramname">request_len</td><td>Then length of the request being sent </td></tr>
    <tr><td class="paramname">include_headers</td><td>If TRUE, include the HTTP headers in the response. </td></tr>
    <tr><td class="paramname">max_len</td><td>The maximum number of bytes to retrieve, or a negative number to use the default max of 512 KiB. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback function. </td></tr>
    <tr><td class="paramname">data</td><td>The user data to pass to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000063">Deprecated:</a></b></dt><dd>In 3.0.0, we'll rename this to "purple_util_fetch_url_request" and get rid of the old one </dd></dl>

</div>
</div>
<a id="a75d854ce14a2384e8fe4fb348b2beec5" name="a75d854ce14a2384e8fe4fb348b2beec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d854ce14a2384e8fe4fb348b2beec5">&#9670;&nbsp;</a></span>purple_util_fetch_url_request_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__PurpleUtilFetchUrlData.html">PurpleUtilFetchUrlData</a> * purple_util_fetch_url_request_len </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>full</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>user_agent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>http11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>include_headers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&#160;</td>
          <td class="paramname"><em>max_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="util_8h.html#a9ad47dea3dfd7e801e022b472c5bf6bc">PurpleUtilFetchUrlCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpointer&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Fetches the data from a URL, and passes it to a callback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>The URL. </td></tr>
    <tr><td class="paramname">full</td><td>TRUE if this is the full URL, or FALSE if it's a partial URL. </td></tr>
    <tr><td class="paramname">user_agent</td><td>The user agent field to use, or NULL. </td></tr>
    <tr><td class="paramname">http11</td><td>TRUE if HTTP/1.1 should be used to download the file. </td></tr>
    <tr><td class="paramname">request</td><td>A HTTP request to send to the server instead of the standard GET </td></tr>
    <tr><td class="paramname">include_headers</td><td>If TRUE, include the HTTP headers in the response. </td></tr>
    <tr><td class="paramname">max_len</td><td>The maximum number of bytes to retrieve (-1 for unlimited) </td></tr>
    <tr><td class="paramname">callback</td><td>The callback function. </td></tr>
    <tr><td class="paramname">data</td><td>The user data to pass to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000061">Deprecated:</a></b></dt><dd>In 3.0.0, this will go away. </dd></dl>

</div>
</div>
<a id="adda0a23d9a4c351f2d435d9ca762f7a3" name="adda0a23d9a4c351f2d435d9ca762f7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda0a23d9a4c351f2d435d9ca762f7a3">&#9670;&nbsp;</a></span>purple_util_fetch_url_request_len_with_account()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__PurpleUtilFetchUrlData.html">PurpleUtilFetchUrlData</a> * purple_util_fetch_url_request_len_with_account </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="account_8h.html#ab9db46cb0fe2619a85a173379c1ae053">PurpleAccount</a> *&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>full</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>user_agent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>http11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>include_headers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&#160;</td>
          <td class="paramname"><em>max_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="util_8h.html#a9ad47dea3dfd7e801e022b472c5bf6bc">PurpleUtilFetchUrlCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpointer&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Fetches the data from a URL, and passes it to a callback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">account</td><td>The account for which the request is needed, or NULL. </td></tr>
    <tr><td class="paramname">url</td><td>The URL. </td></tr>
    <tr><td class="paramname">full</td><td>TRUE if this is the full URL, or FALSE if it's a partial URL. </td></tr>
    <tr><td class="paramname">user_agent</td><td>The user agent field to use, or NULL. </td></tr>
    <tr><td class="paramname">http11</td><td>TRUE if HTTP/1.1 should be used to download the file. </td></tr>
    <tr><td class="paramname">request</td><td>A HTTP request to send to the server instead of the standard GET </td></tr>
    <tr><td class="paramname">include_headers</td><td>If TRUE, include the HTTP headers in the response. </td></tr>
    <tr><td class="paramname">max_len</td><td>The maximum number of bytes to retrieve, or a negative number to use the default max of 512 KiB. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback function. </td></tr>
    <tr><td class="paramname">data</td><td>The user data to pass to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000062">Deprecated:</a></b></dt><dd>In 3.0.0, we'll rename this to "purple_util_fetch_url_request" and get rid of the old one </dd></dl>

</div>
</div>
<a id="a082c5d11d206d570158359569b958dc0" name="a082c5d11d206d570158359569b958dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082c5d11d206d570158359569b958dc0">&#9670;&nbsp;</a></span>purple_util_format_song_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * purple_util_format_song_info </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>artist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>album</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpointer&#160;</td>
          <td class="paramname"><em>unused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Format song information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">title</td><td>The title of the song, <code>NULL</code> to unset the value. </td></tr>
    <tr><td class="paramname">artist</td><td>The artist of the song, can be <code>NULL</code>. </td></tr>
    <tr><td class="paramname">album</td><td>The album of the song, can be <code>NULL</code>. </td></tr>
    <tr><td class="paramname">unused</td><td>Currently unused, must be <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The formatted string. The caller must g_free the returned string. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.4.0 </dd></dl>

</div>
</div>
<a id="a025281925fad3ac1bb3363a19cbc1645" name="a025281925fad3ac1bb3363a19cbc1645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a025281925fad3ac1bb3363a19cbc1645">&#9670;&nbsp;</a></span>purple_util_get_image_checksum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * purple_util_get_image_checksum </td>
          <td>(</td>
          <td class="paramtype">gconstpointer&#160;</td>
          <td class="paramname"><em>image_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>image_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns a SHA-1 hash string of the data passed in. </p>

</div>
</div>
<a id="af4e08707ed4489e9262b4c0577ca12d9" name="af4e08707ed4489e9262b4c0577ca12d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e08707ed4489e9262b4c0577ca12d9">&#9670;&nbsp;</a></span>purple_util_get_image_extension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * purple_util_get_image_extension </td>
          <td>(</td>
          <td class="paramtype">gconstpointer&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns an extension corresponding to the image data's file type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to the image data </td></tr>
    <tr><td class="paramname">len</td><td>The length of the image data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The appropriate extension, or "icon" if unknown. </dd></dl>

</div>
</div>
<a id="a681fa31034357f3c368772159d147c89" name="a681fa31034357f3c368772159d147c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a681fa31034357f3c368772159d147c89">&#9670;&nbsp;</a></span>purple_util_get_image_filename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * purple_util_get_image_filename </td>
          <td>(</td>
          <td class="paramtype">gconstpointer&#160;</td>
          <td class="paramname"><em>image_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>image_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A hex encoded version of the SHA-1 hash of the data passed in with the correct file extention appended. The file extension is determined by calling <a class="el" href="util_8h.html#af4e08707ed4489e9262b4c0577ca12d9">purple_util_get_image_extension()</a>. This return value must be g_freed by the caller. </dd></dl>

</div>
</div>
<a id="ad2a9658a66cbce9424b093f9a83d090c" name="ad2a9658a66cbce9424b093f9a83d090c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a9658a66cbce9424b093f9a83d090c">&#9670;&nbsp;</a></span>purple_util_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void purple_util_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Initializes the utility subsystem.</p>
<dl class="section since"><dt>Since</dt><dd>2.3.0 </dd></dl>

</div>
</div>
<a id="a8f00eb470981fd56d503dc1fc583e5b6" name="a8f00eb470981fd56d503dc1fc583e5b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f00eb470981fd56d503dc1fc583e5b6">&#9670;&nbsp;</a></span>purple_util_read_xml_from_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__xmlnode.html">xmlnode</a> * purple_util_read_xml_from_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read the contents of a given file and parse the results into an xmlnode tree structure. This is intended to be used to read Purple's configuration xml files (prefs.xml, pounces.xml, etc.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The basename of the file to open in the purple_user_dir. </td></tr>
    <tr><td class="paramname">description</td><td>A very short description of the contents of this file. This is used in error messages shown to the user when the file can not be opened. For example, "preferences," or "buddy pounces."</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An xmlnode tree of the contents of the given file. Or NULL, if the file does not exist or there was an error reading the file. </dd></dl>

</div>
</div>
<a id="a399eaa06a3bc2524b00d6c7726359a0e" name="a399eaa06a3bc2524b00d6c7726359a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399eaa06a3bc2524b00d6c7726359a0e">&#9670;&nbsp;</a></span>purple_util_set_current_song()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void purple_util_set_current_song </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>artist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>album</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the appropriate presence values for the currently playing song.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">title</td><td>The title of the song, <code>NULL</code> to unset the value. </td></tr>
    <tr><td class="paramname">artist</td><td>The artist of the song, can be <code>NULL</code>. </td></tr>
    <tr><td class="paramname">album</td><td>The album of the song, can be <code>NULL</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>2.4.0 </dd></dl>

</div>
</div>
<a id="a5614c24a8453a142034eb56839cccd75" name="a5614c24a8453a142034eb56839cccd75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5614c24a8453a142034eb56839cccd75">&#9670;&nbsp;</a></span>purple_util_set_user_dir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void purple_util_set_user_dir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Define a custom purple settings directory, overriding the default (user's home directory/.purple) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>The custom settings directory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a237ab221a242219066c8030405d4c99f" name="a237ab221a242219066c8030405d4c99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237ab221a242219066c8030405d4c99f">&#9670;&nbsp;</a></span>purple_util_uninit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void purple_util_uninit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Uninitializes the util subsystem.</p>
<dl class="section since"><dt>Since</dt><dd>2.3.0 </dd></dl>

</div>
</div>
<a id="a6251bd7f8c1eeca6fa426e9fa5b75616" name="a6251bd7f8c1eeca6fa426e9fa5b75616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6251bd7f8c1eeca6fa426e9fa5b75616">&#9670;&nbsp;</a></span>purple_util_write_data_to_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean purple_util_write_data_to_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Write a string of data to a file of the given name in the Purple user directory ($HOME/.purple by default). The data is typically a serialized version of one of Purple's config files, such as prefs.xml, accounts.xml, etc. And the string is typically obtained using xmlnode_to_formatted_str. However, this function should work fine for saving binary files as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The basename of the file to write in the purple_user_dir. </td></tr>
    <tr><td class="paramname">data</td><td>A null-terminated string of data to write. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data to save. If data is null-terminated you can pass in -1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the file was written successfully. FALSE otherwise. </dd></dl>

</div>
</div>
<a id="a6dd881d7b74ff1a48fe20ea63f364171" name="a6dd881d7b74ff1a48fe20ea63f364171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd881d7b74ff1a48fe20ea63f364171">&#9670;&nbsp;</a></span>purple_util_write_data_to_file_absolute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean purple_util_write_data_to_file_absolute </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename_full</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Write data to a file using the absolute path.</p>
<p >This exists for Glib backwards compatibility reasons.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename_full</td><td>Filename to write to </td></tr>
    <tr><td class="paramname">data</td><td>A null-terminated string of data to write. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data to save. If data is null-terminated you can pass in -1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the file was written successfully. FALSE otherwise.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>Remove this function (use g_file_set_contents instead) when 3.0.0 rolls around. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="util_8h.html#a6251bd7f8c1eeca6fa426e9fa5b75616">purple_util_write_data_to_file()</a> </dd></dl>

</div>
</div>
<a id="a9a60bb236e1dd009c0eae05bb5cfa9e0" name="a9a60bb236e1dd009c0eae05bb5cfa9e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a60bb236e1dd009c0eae05bb5cfa9e0">&#9670;&nbsp;</a></span>purple_uuid_random()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gchar * purple_uuid_random </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns a type 4 (random) UUID</p>
<dl class="section return"><dt>Returns</dt><dd>A UUID, caller is responsible for freeing it </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.7.0 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
