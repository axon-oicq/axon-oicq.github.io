<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: network.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">network.c File Reference<div class="ingroups"><a class="el" href="group__core.html">libpurple</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="internal_8h_source.html">internal.h</a>&quot;</code><br />
<code>#include &lt;arpa/nameser.h&gt;</code><br />
<code>#include &lt;resolv.h&gt;</code><br />
<code>#include &lt;netinet/in.h&gt;</code><br />
<code>#include &lt;net/if.h&gt;</code><br />
<code>#include &lt;sys/ioctl.h&gt;</code><br />
<code>#include &quot;<a class="el" href="debug_8h_source.html">debug.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="account_8h_source.html">account.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="nat-pmp_8h_source.html">nat-pmp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="network_8h_source.html">network.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="prefs_8h_source.html">prefs.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="stun_8h_source.html">stun.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="upnp_8h_source.html">upnp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dnsquery_8h_source.html">dnsquery.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__PurpleNetworkListenData.html">_PurpleNetworkListenData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a8e86913b8ba22db69eebfb3140ae1d12"><td class="memItemLeft" align="right" valign="top"><a id="a8e86913b8ba22db69eebfb3140ae1d12" name="a8e86913b8ba22db69eebfb3140ae1d12"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HX_SIZE_OF_IFREQ</b>(a)&#160;&#160;&#160;sizeof(a)</td></tr>
<tr class="separator:a8e86913b8ba22db69eebfb3140ae1d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa2a218a982dd888a13a99b94af17675e"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="network_8c.html#aa2a218a982dd888a13a99b94af17675e">purple_network_ip_atoi</a> (const char *ip)</td></tr>
<tr class="separator:aa2a218a982dd888a13a99b94af17675e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab524bb6d3a0d98f748502bc9da570419"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="network_8c.html#ab524bb6d3a0d98f748502bc9da570419">purple_network_set_public_ip</a> (const char *ip)</td></tr>
<tr class="separator:ab524bb6d3a0d98f748502bc9da570419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65134bdd81bf1deef6c1834331b99fd4"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="network_8c.html#a65134bdd81bf1deef6c1834331b99fd4">purple_network_get_public_ip</a> (void)</td></tr>
<tr class="separator:a65134bdd81bf1deef6c1834331b99fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46424c9035216ec3d1894b700808ee8e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="network_8c.html#a46424c9035216ec3d1894b700808ee8e">purple_network_get_local_system_ip</a> (int fd)</td></tr>
<tr class="separator:a46424c9035216ec3d1894b700808ee8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3101bc2930af2b43eae09fb2a36dd7cd"><td class="memItemLeft" align="right" valign="top">GList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="network_8c.html#a3101bc2930af2b43eae09fb2a36dd7cd">purple_network_get_all_local_system_ips</a> (void)</td></tr>
<tr class="separator:a3101bc2930af2b43eae09fb2a36dd7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca85adcde8f8397d8652abba07b26b07"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="network_8c.html#aca85adcde8f8397d8652abba07b26b07">purple_network_get_my_ip</a> (int fd)</td></tr>
<tr class="separator:aca85adcde8f8397d8652abba07b26b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f78d20a05182218b33e30a2d52c57fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="network_8c.html#a2f78d20a05182218b33e30a2d52c57fb">purple_network_listen_map_external</a> (gboolean map_external)</td></tr>
<tr class="separator:a2f78d20a05182218b33e30a2d52c57fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9043ad5313058d14e4fdae6805dffd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__PurpleNetworkListenData.html">PurpleNetworkListenData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="network_8c.html#ae9043ad5313058d14e4fdae6805dffd2">purple_network_listen_family</a> (unsigned short port, int socket_family, int socket_type, PurpleNetworkListenCallback cb, gpointer cb_data)</td></tr>
<tr class="separator:ae9043ad5313058d14e4fdae6805dffd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a0f94099fe25b2cf620ba8b3bcaa7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__PurpleNetworkListenData.html">PurpleNetworkListenData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="network_8c.html#a39a0f94099fe25b2cf620ba8b3bcaa7b">purple_network_listen</a> (unsigned short port, int socket_type, PurpleNetworkListenCallback cb, gpointer cb_data)</td></tr>
<tr class="separator:a39a0f94099fe25b2cf620ba8b3bcaa7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc62a3940efdd1d17e702c0b37accd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__PurpleNetworkListenData.html">PurpleNetworkListenData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="network_8c.html#a8cc62a3940efdd1d17e702c0b37accd0">purple_network_listen_range_family</a> (unsigned short start, unsigned short end, int socket_family, int socket_type, PurpleNetworkListenCallback cb, gpointer cb_data)</td></tr>
<tr class="separator:a8cc62a3940efdd1d17e702c0b37accd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a144ac147f794cb67d115c2dc29ef8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__PurpleNetworkListenData.html">PurpleNetworkListenData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="network_8c.html#a60a144ac147f794cb67d115c2dc29ef8">purple_network_listen_range</a> (unsigned short start, unsigned short end, int socket_type, PurpleNetworkListenCallback cb, gpointer cb_data)</td></tr>
<tr class="separator:a60a144ac147f794cb67d115c2dc29ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c358249730a2dd0460f56cb67e9d76d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="network_8c.html#a9c358249730a2dd0460f56cb67e9d76d">purple_network_listen_cancel</a> (<a class="el" href="struct__PurpleNetworkListenData.html">PurpleNetworkListenData</a> *listen_data)</td></tr>
<tr class="separator:a9c358249730a2dd0460f56cb67e9d76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46c29762f85e8b0642a8406c36b32c1"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="network_8c.html#ac46c29762f85e8b0642a8406c36b32c1">purple_network_get_port_from_fd</a> (int fd)</td></tr>
<tr class="separator:ac46c29762f85e8b0642a8406c36b32c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d48a14eba6c66dbe5070aad1bf6574"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="network_8c.html#a52d48a14eba6c66dbe5070aad1bf6574">purple_network_is_available</a> (void)</td></tr>
<tr class="separator:a52d48a14eba6c66dbe5070aad1bf6574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286851c5b7e2f79e52bdf7be4f74257f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="network_8c.html#a286851c5b7e2f79e52bdf7be4f74257f">purple_network_force_online</a> ()</td></tr>
<tr class="separator:a286851c5b7e2f79e52bdf7be4f74257f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7710d0a27c94a7a47e1a26bb369d4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="network_8c.html#aea7710d0a27c94a7a47e1a26bb369d4d">purple_network_set_stun_server</a> (const gchar *stun_server)</td></tr>
<tr class="separator:aea7710d0a27c94a7a47e1a26bb369d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb679af833de50b6a93c4cc8a0165b73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="network_8c.html#afb679af833de50b6a93c4cc8a0165b73">purple_network_set_turn_server</a> (const gchar *turn_server)</td></tr>
<tr class="separator:afb679af833de50b6a93c4cc8a0165b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38969cf83110e312415ac7acb947a15"><td class="memItemLeft" align="right" valign="top">const gchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="network_8c.html#ae38969cf83110e312415ac7acb947a15">purple_network_get_stun_ip</a> (void)</td></tr>
<tr class="separator:ae38969cf83110e312415ac7acb947a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2097a14f91d8dbfd4382638af8e4b7"><td class="memItemLeft" align="right" valign="top">const gchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="network_8c.html#abc2097a14f91d8dbfd4382638af8e4b7">purple_network_get_turn_ip</a> (void)</td></tr>
<tr class="separator:abc2097a14f91d8dbfd4382638af8e4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e43ceb5e86b2c998969cfb634780cf0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="network_8c.html#a1e43ceb5e86b2c998969cfb634780cf0">purple_network_get_handle</a> (void)</td></tr>
<tr class="separator:a1e43ceb5e86b2c998969cfb634780cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbcf61dea780fc54f7e02c7ee96ea25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="network_8c.html#a1fbcf61dea780fc54f7e02c7ee96ea25">purple_network_remove_port_mapping</a> (gint fd)</td></tr>
<tr class="separator:a1fbcf61dea780fc54f7e02c7ee96ea25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4fbe1de2bdc6ad9a48f97bba29c4c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="network_8c.html#acc4fbe1de2bdc6ad9a48f97bba29c4c9">purple_network_convert_idn_to_ascii</a> (const gchar *in, gchar **out)</td></tr>
<tr class="separator:acc4fbe1de2bdc6ad9a48f97bba29c4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc5ad4da12d36dcd0849ac35058d2f2"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="network_8c.html#a7fc5ad4da12d36dcd0849ac35058d2f2">_purple_network_set_common_socket_flags</a> (int fd)</td></tr>
<tr class="separator:a7fc5ad4da12d36dcd0849ac35058d2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad399566a50ee9b389f3d614d73df9cdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="network_8c.html#ad399566a50ee9b389f3d614d73df9cdf">purple_network_init</a> (void)</td></tr>
<tr class="separator:ad399566a50ee9b389f3d614d73df9cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad08291eb1573dd5edd846e9358f62c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="network_8c.html#afad08291eb1573dd5edd846e9358f62c">purple_network_uninit</a> (void)</td></tr>
<tr class="separator:afad08291eb1573dd5edd846e9358f62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Network Implementation </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a7fc5ad4da12d36dcd0849ac35058d2f2" name="a7fc5ad4da12d36dcd0849ac35058d2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc5ad4da12d36dcd0849ac35058d2f2">&#9670;&nbsp;</a></span>_purple_network_set_common_socket_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean _purple_network_set_common_socket_flags </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets most commonly used socket flags: O_NONBLOCK and FD_CLOEXEC.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The file descriptor for the socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if succeeded, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="acc4fbe1de2bdc6ad9a48f97bba29c4c9" name="acc4fbe1de2bdc6ad9a48f97bba29c4c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4fbe1de2bdc6ad9a48f97bba29c4c9">&#9670;&nbsp;</a></span>purple_network_convert_idn_to_ascii()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int purple_network_convert_idn_to_ascii </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gchar **&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Convert a UTF-8 domain name to ASCII in accordance with the IDNA specification. If libpurple is compiled without IDN support, this function copies the input into the output buffer.</p>
<p >Because this function is used by DNS resolver child/threads, it uses no other libpurple API and is threadsafe.</p>
<p >In general, a buffer of about 512 bytes is the appropriate size to use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The hostname to be converted. </td></tr>
    <tr><td class="paramname">out</td><td>The output buffer where an allocated string will be returned. The caller is responsible for freeing this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 if the out is NULL, or an error code that currently corresponds to the Idna_rc enum in libidn. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.6.0 </dd></dl>

</div>
</div>
<a id="a286851c5b7e2f79e52bdf7be4f74257f" name="a286851c5b7e2f79e52bdf7be4f74257f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286851c5b7e2f79e52bdf7be4f74257f">&#9670;&nbsp;</a></span>purple_network_force_online()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void purple_network_force_online </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Makes <a class="el" href="network_8h.html#a52d48a14eba6c66dbe5070aad1bf6574">purple_network_is_available()</a> always return <code>TRUE</code>.</p>
<p >This is what backs the &ndash;force-online command line argument in Pidgin, for example. This is useful for offline testing, especially when combined with nullprpl.</p>
<dl class="section since"><dt>Since</dt><dd>2.6.0 </dd></dl>

</div>
</div>
<a id="a3101bc2930af2b43eae09fb2a36dd7cd" name="a3101bc2930af2b43eae09fb2a36dd7cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3101bc2930af2b43eae09fb2a36dd7cd">&#9670;&nbsp;</a></span>purple_network_get_all_local_system_ips()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GList * purple_network_get_all_local_system_ips </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns all IP addresses of the local system.</p>
<dl class="section note"><dt>Note</dt><dd>The caller must free this list. If libpurple was built with support for it, this function also enumerates IPv6 addresses. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.7.0</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A list of local IP addresses. </dd></dl>

</div>
</div>
<a id="a1e43ceb5e86b2c998969cfb634780cf0" name="a1e43ceb5e86b2c998969cfb634780cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e43ceb5e86b2c998969cfb634780cf0">&#9670;&nbsp;</a></span>purple_network_get_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * purple_network_get_handle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the handle for the network system</p>
<dl class="section return"><dt>Returns</dt><dd>the handle to the network system </dd></dl>

</div>
</div>
<a id="a46424c9035216ec3d1894b700808ee8e" name="a46424c9035216ec3d1894b700808ee8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46424c9035216ec3d1894b700808ee8e">&#9670;&nbsp;</a></span>purple_network_get_local_system_ip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * purple_network_get_local_system_ip </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the IP address of the local system.</p>
<p >You probably want to use <a class="el" href="network_8h.html#aca85adcde8f8397d8652abba07b26b07">purple_network_get_my_ip()</a> instead.</p>
<dl class="section note"><dt>Note</dt><dd>The returned string is a pointer to a static buffer. If this function is called twice, it may be important to make a copy of the returned string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The fd to use to help figure out the IP, or else -1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The local IP address. </dd></dl>

</div>
</div>
<a id="aca85adcde8f8397d8652abba07b26b07" name="aca85adcde8f8397d8652abba07b26b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca85adcde8f8397d8652abba07b26b07">&#9670;&nbsp;</a></span>purple_network_get_my_ip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * purple_network_get_my_ip </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the IP address that should be used anywhere a public IP addresses is needed (listening for an incoming file transfer, etc).</p>
<p >If the user has manually specified an IP address via preferences, then this IP is returned. Otherwise the IP address returned by <a class="el" href="network_8h.html#a46424c9035216ec3d1894b700808ee8e">purple_network_get_local_system_ip()</a> is returned.</p>
<dl class="section note"><dt>Note</dt><dd>The returned string is a pointer to a static buffer. If this function is called twice, it may be important to make a copy of the returned string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The fd to use to help figure out the IP, or -1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The local IP address to be used. </dd></dl>

</div>
</div>
<a id="ac46c29762f85e8b0642a8406c36b32c1" name="ac46c29762f85e8b0642a8406c36b32c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac46c29762f85e8b0642a8406c36b32c1">&#9670;&nbsp;</a></span>purple_network_get_port_from_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short purple_network_get_port_from_fd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets a port number from a file descriptor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The file descriptor. This should be a tcp socket. The current implementation probably dies on anything but IPv4. Perhaps this possible bug will inspire new and valuable contributors to Purple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The port number, in host byte order. </dd></dl>

</div>
</div>
<a id="a65134bdd81bf1deef6c1834331b99fd4" name="a65134bdd81bf1deef6c1834331b99fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65134bdd81bf1deef6c1834331b99fd4">&#9670;&nbsp;</a></span>purple_network_get_public_ip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * purple_network_get_public_ip </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the IP address of the local system set in preferences.</p>
<p >This returns the value set via <a class="el" href="network_8h.html#ab524bb6d3a0d98f748502bc9da570419">purple_network_set_public_ip()</a>. You probably want to use <a class="el" href="network_8h.html#aca85adcde8f8397d8652abba07b26b07">purple_network_get_my_ip()</a> instead.</p>
<dl class="section return"><dt>Returns</dt><dd>The local IP address set in preferences. </dd></dl>

</div>
</div>
<a id="ae38969cf83110e312415ac7acb947a15" name="ae38969cf83110e312415ac7acb947a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae38969cf83110e312415ac7acb947a15">&#9670;&nbsp;</a></span>purple_network_get_stun_ip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const gchar * purple_network_get_stun_ip </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the IP address of the STUN server as a string representation</p>
<dl class="section return"><dt>Returns</dt><dd>the IP address </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.6.0 </dd></dl>

</div>
</div>
<a id="abc2097a14f91d8dbfd4382638af8e4b7" name="abc2097a14f91d8dbfd4382638af8e4b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc2097a14f91d8dbfd4382638af8e4b7">&#9670;&nbsp;</a></span>purple_network_get_turn_ip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const gchar * purple_network_get_turn_ip </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the IP address of the TURN server as a string representation</p>
<dl class="section return"><dt>Returns</dt><dd>the IP address </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.6.0 </dd></dl>

</div>
</div>
<a id="ad399566a50ee9b389f3d614d73df9cdf" name="ad399566a50ee9b389f3d614d73df9cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad399566a50ee9b389f3d614d73df9cdf">&#9670;&nbsp;</a></span>purple_network_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void purple_network_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Initializes the network subsystem. </p>

</div>
</div>
<a id="aa2a218a982dd888a13a99b94af17675e" name="aa2a218a982dd888a13a99b94af17675e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a218a982dd888a13a99b94af17675e">&#9670;&nbsp;</a></span>purple_network_ip_atoi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char * purple_network_ip_atoi </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Converts a dot-decimal IP address to an array of unsigned chars. For example, converts 192.168.0.1 to a 4 byte array containing 192, 168, 0 and 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>An IP address in dot-decimal notiation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of 4 bytes containing an IP addresses equivalent to the given parameter, or NULL if the given IP address is invalid. This value is statically allocated and should not be freed. </dd></dl>

</div>
</div>
<a id="a52d48a14eba6c66dbe5070aad1bf6574" name="a52d48a14eba6c66dbe5070aad1bf6574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d48a14eba6c66dbe5070aad1bf6574">&#9670;&nbsp;</a></span>purple_network_is_available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean purple_network_is_available </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Detects if there is an available network connection.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the network is available </dd></dl>

</div>
</div>
<a id="a39a0f94099fe25b2cf620ba8b3bcaa7b" name="a39a0f94099fe25b2cf620ba8b3bcaa7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a0f94099fe25b2cf620ba8b3bcaa7b">&#9670;&nbsp;</a></span>purple_network_listen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__PurpleNetworkListenData.html">PurpleNetworkListenData</a> * purple_network_listen </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PurpleNetworkListenCallback&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpointer&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attempts to open a listening port ONLY on the specified port number. You probably want to use <a class="el" href="network_8h.html#a60a144ac147f794cb67d115c2dc29ef8">purple_network_listen_range()</a> instead of this. This function is useful, for example, if you wanted to write a telnet server as a Purple plugin, and you HAD to listen on port 23. Why anyone would want to do that is beyond me.</p>
<p >This opens a listening port. The caller will want to set up a watcher of type PURPLE_INPUT_READ on the fd returned in cb. It will probably call accept in the watcher callback, and then possibly remove the watcher and close the listening socket, and add a new watcher on the new socket accept returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port number to bind to. Must be greater than 0. </td></tr>
    <tr><td class="paramname">socket_type</td><td>The type of socket to open for listening. This will be either SOCK_STREAM for TCP or SOCK_DGRAM for UDP. </td></tr>
    <tr><td class="paramname">cb</td><td>The callback to be invoked when the port to listen on is available. The file descriptor of the listening socket will be specified in this callback, or -1 if no socket could be established. </td></tr>
    <tr><td class="paramname">cb_data</td><td>extra data to be returned when cb is called</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a data structure that can be used to cancel the pending listener, or NULL if unable to obtain a local socket to listen on. </dd></dl>

</div>
</div>
<a id="a9c358249730a2dd0460f56cb67e9d76d" name="a9c358249730a2dd0460f56cb67e9d76d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c358249730a2dd0460f56cb67e9d76d">&#9670;&nbsp;</a></span>purple_network_listen_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void purple_network_listen_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__PurpleNetworkListenData.html">PurpleNetworkListenData</a> *&#160;</td>
          <td class="paramname"><em>listen_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This can be used to cancel any in-progress listener connection by passing in the return value from either <a class="el" href="network_8h.html#a39a0f94099fe25b2cf620ba8b3bcaa7b">purple_network_listen()</a> or <a class="el" href="network_8h.html#a60a144ac147f794cb67d115c2dc29ef8">purple_network_listen_range()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listen_data</td><td>This listener attempt will be cancelled and the struct will be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9043ad5313058d14e4fdae6805dffd2" name="ae9043ad5313058d14e4fdae6805dffd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9043ad5313058d14e4fdae6805dffd2">&#9670;&nbsp;</a></span>purple_network_listen_family()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__PurpleNetworkListenData.html">PurpleNetworkListenData</a> * purple_network_listen_family </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PurpleNetworkListenCallback&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpointer&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p >Attempts to open a listening port ONLY on the specified port number. You probably want to use <a class="el" href="network_8h.html#a60a144ac147f794cb67d115c2dc29ef8">purple_network_listen_range()</a> instead of this. This function is useful, for example, if you wanted to write a telnet server as a Purple plugin, and you HAD to listen on port 23. Why anyone would want to do that is beyond me.</p>
<p >This opens a listening port. The caller will want to set up a watcher of type PURPLE_INPUT_READ on the fd returned in cb. It will probably call accept in the watcher callback, and then possibly remove the watcher and close the listening socket, and add a new watcher on the new socket accept returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port number to bind to. Must be greater than 0. </td></tr>
    <tr><td class="paramname">socket_type</td><td>The type of socket to open for listening. This will be either SOCK_STREAM for TCP or SOCK_DGRAM for UDP. </td></tr>
    <tr><td class="paramname">cb</td><td>The callback to be invoked when the port to listen on is available. The file descriptor of the listening socket will be specified in this callback, or -1 if no socket could be established. </td></tr>
    <tr><td class="paramname">cb_data</td><td>extra data to be returned when cb is called</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a data structure that can be used to cancel the pending listener, or NULL if unable to obtain a local socket to listen on.</dd></dl>
<p>Libpurple does not currently do any port mapping (stateful firewall hole poking) for IPv6-only listeners (if an IPv6 socket supports v4-mapped addresses, a mapping is done).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_family</td><td>The protocol family of the socket. This should be AF_INET for IPv4 or AF_INET6 for IPv6. IPv6 sockets may or may not be able to accept IPv4 connections based on the system configuration (use purple_socket_speaks_ipv4 to check). If an IPv6 socket doesn't accept V4-mapped addresses, you will need a second listener to support both v4 and v6. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>2.7.0 </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000028">Deprecated:</a></b></dt><dd>This function will be renamed to purple_network_listen in 3.0.0. </dd></dl>

</div>
</div>
<a id="a2f78d20a05182218b33e30a2d52c57fb" name="a2f78d20a05182218b33e30a2d52c57fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f78d20a05182218b33e30a2d52c57fb">&#9670;&nbsp;</a></span>purple_network_listen_map_external()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void purple_network_listen_map_external </td>
          <td>(</td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>map_external</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Should calls to <a class="el" href="network_8h.html#a39a0f94099fe25b2cf620ba8b3bcaa7b">purple_network_listen()</a> and <a class="el" href="network_8h.html#a60a144ac147f794cb67d115c2dc29ef8">purple_network_listen_range()</a> map the port externally using NAT-PMP or UPnP? The default value is TRUE</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map_external</td><td>Should the open port be mapped externally? </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000027">Deprecated:</a></b></dt><dd>In 3.0.0 a boolean will be added to the functions mentioned above to perform the same function. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.3.0 </dd></dl>

</div>
</div>
<a id="a60a144ac147f794cb67d115c2dc29ef8" name="a60a144ac147f794cb67d115c2dc29ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a144ac147f794cb67d115c2dc29ef8">&#9670;&nbsp;</a></span>purple_network_listen_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__PurpleNetworkListenData.html">PurpleNetworkListenData</a> * purple_network_listen_range </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PurpleNetworkListenCallback&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpointer&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Opens a listening port selected from a range of ports. The range of ports used is chosen in the following manner: If a range is specified in preferences, these values are used. If a non-0 values are passed to the function as parameters, these values are used. Otherwise a port is chosen at random by the operating system.</p>
<p >This opens a listening port. The caller will want to set up a watcher of type PURPLE_INPUT_READ on the fd returned in cb. It will probably call accept in the watcher callback, and then possibly remove the watcher and close the listening socket, and add a new watcher on the new socket accept returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The port number to bind to, or 0 to pick a random port. Users are allowed to override this arg in prefs. </td></tr>
    <tr><td class="paramname">end</td><td>The highest possible port in the range of ports to listen on, or 0 to pick a random port. Users are allowed to override this arg in prefs. </td></tr>
    <tr><td class="paramname">socket_type</td><td>The type of socket to open for listening. This will be either SOCK_STREAM for TCP or SOCK_DGRAM for UDP. </td></tr>
    <tr><td class="paramname">cb</td><td>The callback to be invoked when the port to listen on is available. The file descriptor of the listening socket will be specified in this callback, or -1 if no socket could be established. </td></tr>
    <tr><td class="paramname">cb_data</td><td>extra data to be returned when cb is called</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a data structure that can be used to cancel the pending listener, or NULL if unable to obtain a local socket to listen on. </dd></dl>

</div>
</div>
<a id="a8cc62a3940efdd1d17e702c0b37accd0" name="a8cc62a3940efdd1d17e702c0b37accd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc62a3940efdd1d17e702c0b37accd0">&#9670;&nbsp;</a></span>purple_network_listen_range_family()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__PurpleNetworkListenData.html">PurpleNetworkListenData</a> * purple_network_listen_range_family </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PurpleNetworkListenCallback&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpointer&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p >Opens a listening port selected from a range of ports. The range of ports used is chosen in the following manner: If a range is specified in preferences, these values are used. If a non-0 values are passed to the function as parameters, these values are used. Otherwise a port is chosen at random by the operating system.</p>
<p >This opens a listening port. The caller will want to set up a watcher of type PURPLE_INPUT_READ on the fd returned in cb. It will probably call accept in the watcher callback, and then possibly remove the watcher and close the listening socket, and add a new watcher on the new socket accept returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The port number to bind to, or 0 to pick a random port. Users are allowed to override this arg in prefs. </td></tr>
    <tr><td class="paramname">end</td><td>The highest possible port in the range of ports to listen on, or 0 to pick a random port. Users are allowed to override this arg in prefs. </td></tr>
    <tr><td class="paramname">socket_type</td><td>The type of socket to open for listening. This will be either SOCK_STREAM for TCP or SOCK_DGRAM for UDP. </td></tr>
    <tr><td class="paramname">cb</td><td>The callback to be invoked when the port to listen on is available. The file descriptor of the listening socket will be specified in this callback, or -1 if no socket could be established. </td></tr>
    <tr><td class="paramname">cb_data</td><td>extra data to be returned when cb is called</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a data structure that can be used to cancel the pending listener, or NULL if unable to obtain a local socket to listen on.</dd></dl>
<p>Libpurple does not currently do any port mapping (stateful firewall hole poking) for IPv6-only listeners (if an IPv6 socket supports v4-mapped addresses, a mapping is done).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_family</td><td>The protocol family of the socket. This should be AF_INET for IPv4 or AF_INET6 for IPv6. IPv6 sockets may or may not be able to accept IPv4 connections based on the system configuration (use purple_socket_speaks_ipv4 to check). If an IPv6 socket doesn't accept V4-mapped addresses, you will need a second listener to support both v4 and v6. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>2.7.0 </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000029">Deprecated:</a></b></dt><dd>This function will be renamed to purple_network_listen_range in 3.0.0. </dd></dl>

</div>
</div>
<a id="a1fbcf61dea780fc54f7e02c7ee96ea25" name="a1fbcf61dea780fc54f7e02c7ee96ea25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fbcf61dea780fc54f7e02c7ee96ea25">&#9670;&nbsp;</a></span>purple_network_remove_port_mapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void purple_network_remove_port_mapping </td>
          <td>(</td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Remove a port mapping (UPnP or NAT-PMP) associated with listening socket</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>Socket to remove the port mapping for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>2.6.0 </dd></dl>

</div>
</div>
<a id="ab524bb6d3a0d98f748502bc9da570419" name="ab524bb6d3a0d98f748502bc9da570419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab524bb6d3a0d98f748502bc9da570419">&#9670;&nbsp;</a></span>purple_network_set_public_ip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void purple_network_set_public_ip </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the IP address of the local system in preferences. This is the IP address that should be used for incoming connections (file transfer, direct IM, etc.) and should therefore be publicly accessible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>The local IP address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea7710d0a27c94a7a47e1a26bb369d4d" name="aea7710d0a27c94a7a47e1a26bb369d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7710d0a27c94a7a47e1a26bb369d4d">&#9670;&nbsp;</a></span>purple_network_set_stun_server()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void purple_network_set_stun_server </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>stun_server</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Update the STUN server IP given the host name Will result in a DNS query being executed asynchronous</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stun_server</td><td>The host name of the STUN server to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>2.6.0 </dd></dl>

</div>
</div>
<a id="afb679af833de50b6a93c4cc8a0165b73" name="afb679af833de50b6a93c4cc8a0165b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb679af833de50b6a93c4cc8a0165b73">&#9670;&nbsp;</a></span>purple_network_set_turn_server()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void purple_network_set_turn_server </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>turn_server</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Update the TURN server IP given the host name Will result in a DNS query being executed asynchronous</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">turn_server</td><td>The host name of the TURN server to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>2.6.0 </dd></dl>

</div>
</div>
<a id="afad08291eb1573dd5edd846e9358f62c" name="afad08291eb1573dd5edd846e9358f62c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad08291eb1573dd5edd846e9358f62c">&#9670;&nbsp;</a></span>purple_network_uninit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void purple_network_uninit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Shuts down the network subsystem. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
